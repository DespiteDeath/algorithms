// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "About author",
      "url": "/algorithms/about_me.html",
      "content": "About author My name is Artem Korsakov (Артём Корсаков). I am a QA Automation Engineer. I love mathematics and algorithms. I created this library for solving problems on project Euler. Here are only well-known algorithms - there are no solutions to problems from Euler project. My results on Euler project are Contact with me (Russian or English) github email linkedIn"
    } ,    
    {
      "title": "Binary Tree",
      "url": "/algorithms/docs/trees/binary_tree.html",
      "content": "Common operations nodeCount - count of nodes in the binary tree. height - binary tree height. leafCount - count of leaf. A leaf is a node with no successors. leafList - collect leaf in a list. internalList - list of internal nodes. An internal node of a binary tree has either one or two non-empty successors. atLevel(level: Int) - Collect the nodes at a given level in a list. The root node is at level 1. A node of a binary tree is at level N if the path from the root to the node has length N-1. isMirrorOf - is the given tree a mirror image in the structure? isSymmetric - is the given tree a symmetric binary trees? Let us call a binary tree symmetric if you can draw a vertical line through the root node and then the right subtree is the mirror image in the structure of the left subtree. addValue - add an element to a binary search tree. mirror - the mirror tree. fromList - generate tree from list. fromString - generate tree from string. completeBinaryTree(nodes: Int, value: T) - A complete binary tree. A complete binary tree with height H is defined as follows: The levels 1,2,3,…,H-1 contain the maximum number of nodes (i.e 2(i-1) at the level i, note that we start counting the levels from 1 at the root). In level H, which may contain less than the maximum possible number of nodes, all the nodes are “left-adjusted”. This means that in a levelorder tree traversal all internal nodes come first, the leaves come second, and empty successors (the Ends which are not really nodes!) come last. Algorithm Complexity Sources Ninety-Nine Scala Problems Using import com.github.artemkorsakov.trees.BinaryTree.Tree._ import com.github.artemkorsakov.trees.BinaryTree._ val simpleTree = Node('a', Node('b', Node('d'), Node('e')), Node('c', End, Node('f', Node('g'), End))) // simpleTree: Node[Char] = Node( // value = 'a', // left = Node( // value = 'b', // left = Node(value = 'd', left = , right = ), // right = Node(value = 'e', left = , right = ) // ), // right = Node( // value = 'c', // left = , // right = Node( // value = 'f', // left = Node(value = 'g', left = , right = ), // right = // ) // ) // ) simpleTree.nodeCount // res0: Int = 7 simpleTree.height // res1: Int = 4 simpleTree.leafCount // res2: Int = 3 simpleTree.leafList // res3: List[Char] = List('d', 'e', 'g') simpleTree.internalList // res4: List[Char] = List('a', 'b', 'c', 'f') simpleTree.atLevel(3) // res5: List[Char] = List('d', 'e', 'f') simpleTree.isMirrorOf(Node('a', Node('b', Node('d', End, Node('e')), End), Node('c', Node('g'), Node('f')))) // res6: Boolean = true simpleTree.isSymmetric // res7: Boolean = false Node('a', Node('b', Node('d', End, Node('e')), End), Node('c', End, Node('f', Node('g'), End))).isSymmetric // res8: Boolean = true End.addValue(2).addValue(3).addValue(0).addValue(1).addValue(-1) // res9: Tree[Int] = Node( // value = 2, // left = Node( // value = 0, // left = Node(value = -1, left = , right = ), // right = Node(value = 1, left = , right = ) // ), // right = Node(value = 3, left = , right = ) // ) mirror(simpleTree) // res10: Tree[Char] = Node( // value = 'a', // left = Node( // value = 'c', // left = Node( // value = 'f', // left = , // right = Node(value = 'g', left = , right = ) // ), // right = // ), // right = Node( // value = 'b', // left = Node(value = 'e', left = , right = ), // right = Node(value = 'd', left = , right = ) // ) // ) Tree.fromList(List(5, 3, 18, 1, 4, 12, 21)) // res11: Tree[Int] = Node( // value = 5, // left = Node( // value = 3, // left = Node(value = 1, left = , right = ), // right = Node(value = 4, left = , right = ) // ), // right = Node( // value = 18, // left = Node(value = 12, left = , right = ), // right = Node(value = 21, left = , right = ) // ) // ) Tree.fromString(\"a(b(d,e),c(,f(g,)))\") // res12: Tree[Char] = Node( // value = 'a', // left = Node( // value = 'b', // left = Node(value = 'd', left = , right = ), // right = Node(value = 'e', left = , right = ) // ), // right = Node( // value = 'c', // left = , // right = Node( // value = 'f', // left = Node(value = 'g', left = , right = ), // right = // ) // ) // ) Tree.completeBinaryTree(17, \"x\") // res13: Tree[String] = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ), // right = Node(value = \"x\", left = , right = ) // ), // right = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ) // ), // right = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ), // right = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ) // ) // )"
    } ,    
    {
      "title": "Binomial Coefficient",
      "url": "/algorithms/docs/combinatorics/binomial_coefficient.html",
      "content": "Operations with binomial coefficient. binomialCoefficient Calculate binomial coefficient Algorithm if k &lt; 0 or k &gt; n return 0. Complexity O(n) Sources Wikipedia Using import com.github.artemkorsakov.combinatorics.BinomialCoefficient._ binomialCoefficient(100, 68) // res0: BigInt = 143012501349174257560226775 binomialCoefficient(100, 68, 1000000) // res1: BigInt = 226775"
    } ,    
    {
      "title": "Changelog",
      "url": "/algorithms/changelog.html",
      "content": "Changelog v0.1.2 Features: Update sbt version. v0.1.1 Features: Update documentation. v0.1.0 Features: Publish complete package com.github.artemkorsakov.games with algorithms for different games. v0.0.15 Features: Integration with Travis CI. v0.0.8 Features: Add some methods to package com.github.artemkorsakov.numbers. v0.0.7 Features: Publish complete package com.github.artemkorsakov.numbers for operations with various numbers. Publish complete package com.github.artemkorsakov.objects for operations with various math objects such as matrix. Publish complete package com.github.artemkorsakov.operations contains various simple algorithms. v0.0.6 Features: Publish complete package com.github.artemkorsakov.digital for operations with digits. Publish complete package com.github.artemkorsakov.divisors for operations with divisors. Publish complete package com.github.artemkorsakov.sort for sorting algorithms. Publish complete package com.github.artemkorsakov.str for string algorithms. v0.0.5 Features: Publish complete package com.github.artemkorsakov.combinatorics for Combinatorics algorithms. v0.0.4 Features: Publish complete package com.github.artemkorsakov.primes for working with prime numbers, Euler’s totient function, the radical of a positive integer n. v0.0.3 Features: Create Algorithms library Create Documentation and ScalaDoc Publish library to the Maven Central Repository Add first package com.github.artemkorsakov.primes for working with prime numbers."
    } ,    
    {
      "title": "Chinese Remainder T.",
      "url": "/algorithms/docs/divisors/chinese_remainder_theorem.html",
      "content": "Chinese Remainder Theorem. solution Return n, such than n % ai = ri. Algorithm Calculate . For all find . Find . Return result . Complexity Sources Chinese Remainder Theorem Using import com.github.artemkorsakov.divisors.ChineseRemainderTheorem._ solution(Array(707, 527), Array(0, 5)) // res0: BigInt = 258762"
    } ,    
    {
      "title": "Coins",
      "url": "/algorithms/docs/combinatorics/coins.html",
      "content": "countWays In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p). It is possible to make £2 in the following way: 1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p How many different ways can £2 be made using any number of coins? Algorithm Let’s define ways as an array of numbers where ways(0) = 1. For each coin for each i from coin to sum let’s calculate ways(i) as ways(i) + ways(i - coin). Return ways(sum). Complexity Sources Project Euler: Coin sums Project Euler: Coin sums (overview) Using import com.github.artemkorsakov.combinatorics.Coins._ countWays(Array(1, 2, 5, 10, 20, 50, 100, 200), 200) // res0: Long = 73682L partition In number theory and combinatorics, a partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers. Two sums that differ only in the order of their summands are considered the same partition. (If order matters, the sum becomes a composition.) Algorithm Complexity Sources Wikipedia Using 1000.partition // res1: BigInt = 24061467864032622473692149727991 optionsToGetSumAsASumOfAtLeastTwoPositiveNumbers How many options to get sum as a sum of at least two positive numbers? Algorithm sum.partition - 1. Complexity Sources Using optionsToGetSumAsASumOfAtLeastTwoPositiveNumbers(100) // res2: BigInt = 190569291"
    } ,    
    {
      "title": "Collatz number",
      "url": "/algorithms/docs/numbers/collatz.html",
      "content": "Returns count of Collatz conjecture’s steps. collatz Algorithm Complexity Sources Collatz conjecture Using import com.github.artemkorsakov.numbers.CollatzNumber._ 1.collatz // res0: Int = 0 3.collatz // res1: Int = 7 19.collatz // res2: Int = 20 27.collatz // res3: Int = 111"
    } ,    
    {
      "title": "Combinatorics",
      "url": "/algorithms/docs/combinatorics.html",
      "content": "Combinatorics The package com.github.artemkorsakov.combinatorics contains Combinatorics algorithms. You can use the package, for example, like this: import com.github.artemkorsakov.combinatorics.BinomialCoefficient._ binomialCoefficient(100, 68) // res0: BigInt = 143012501349174257560226775 binomialCoefficient(100, 68, 1000000) // res1: BigInt = 226775 import com.github.artemkorsakov.combinatorics.Coins._ countWays(Array(1, 2, 5, 10, 20, 50, 100, 200), 200) // res2: Long = 73682L 1000.partition // res3: BigInt = 24061467864032622473692149727991 optionsToGetSumAsASumOfAtLeastTwoPositiveNumbers(100) // res4: BigInt = 190569291 import com.github.artemkorsakov.combinatorics.Factorials._ 30.factorial // res5: BigInt = 265252859812191058636308480000000 import com.github.artemkorsakov.combinatorics.ThreeColours._ countABCRows(2, 2, 2) // res6: Long = 90L"
    } ,    
    {
      "title": "Common operations",
      "url": "/algorithms/docs/operations/common_operations.html",
      "content": "Common simple operations. sumToGiven The sum of the n first numbers. Algorithm Complexity O(1) Sources Sum Using import com.github.artemkorsakov.operations.CommonOperations._ sumToGiven(1000000) // res0: Long = 500000500000L sumOfSquaresTo The sum of the n first square numbers. Algorithm Complexity O(1) Sources Square number Using sumOfSquaresTo(1000) // res1: Long = 333833500L sumOfCubesTo The sum of the n first cubes numbers. Algorithm Complexity O(1) Sources Cube Using sumOfCubesTo(1000) // res2: Long = 250500250000L sqrt A square root of a number x. Algorithm Complexity Sources Square root Using 1000.sqrt // res3: Double = 31.622776601684336 isSquare Is a number a square? Algorithm Complexity Sources Using 36.isSquare // res4: Boolean = true allSquares All square numbers the number of digits in which is equal to the given. All square numbers from start (inclusive) to finish (inclusive). Algorithm Complexity Sources Using allSquares(2) // res5: IndexedSeq[Int] = Vector(16, 25, 36, 49, 64, 81) allSquares(1024, 1444) // res6: IndexedSeq[Int] = Vector(1024, 1089, 1156, 1225, 1296, 1369, 1444) allNumbersVariants Returns a list of unique lists containing given numbers without repetition. Algorithm Complexity Sources Using allNumbersVariants(Set(2, 3, 5)) // res7: Set[Set[Int]] = HashSet( // Set(5, 3, 2), // Set(2), // Set(3, 2), // Set(5), // Set(5, 2), // Set(3), // Set(5, 3) // )"
    } ,    
    {
      "title": "Complex number",
      "url": "/algorithms/docs/numbers/complex.html",
      "content": "A complex number is a number that can be expressed in the form a + bi, where a and b are real numbers, and i represents the imaginary unit, satisfying the equation i2 = -1. complexOperations Algorithm Complexity Sources Complex number Using import com.github.artemkorsakov.numbers.ComplexNumber ComplexNumber(2, 3).add(ComplexNumber(1, 4)) // res0: ComplexNumber = ComplexNumber(a = 3.0, b = 7.0) ComplexNumber(2, 3) + ComplexNumber(1, 4) // res1: ComplexNumber = ComplexNumber(a = 3.0, b = 7.0) ComplexNumber(2, 3).sub(ComplexNumber(1, 4)) // res2: ComplexNumber = ComplexNumber(a = 1.0, b = -1.0) ComplexNumber(2, 3) - ComplexNumber(1, 4) // res3: ComplexNumber = ComplexNumber(a = 1.0, b = -1.0) ComplexNumber(2, 3).mul(ComplexNumber(1, 4)) // res4: ComplexNumber = ComplexNumber(a = -10.0, b = 11.0) ComplexNumber(2, 3) * ComplexNumber(1, 4) // res5: ComplexNumber = ComplexNumber(a = -10.0, b = 11.0) ComplexNumber(2, 3).div(ComplexNumber(1, 4)) // res6: ComplexNumber = ComplexNumber( // a = 0.8235294117647058, // b = -0.29411764705882354 // ) ComplexNumber(2, 3) / ComplexNumber(1, 4) // res7: ComplexNumber = ComplexNumber( // a = 0.8235294117647058, // b = -0.29411764705882354 // ) (ComplexNumber(1, 1) * ComplexNumber(2, 1) * ComplexNumber(3, 1)) / ComplexNumber(1, -1) // res8: ComplexNumber = ComplexNumber(a = -5.0, b = 5.0) ComplexNumber(1, 1) / ComplexNumber(1, -1) // res9: ComplexNumber = ComplexNumber(a = 0.0, b = 1.0) ComplexNumber(1, 1) / ComplexNumber(2, -1) // res10: ComplexNumber = ComplexNumber(a = 0.2, b = 0.6) ComplexNumber(1, 0) / ComplexNumber(0, 1) // res11: ComplexNumber = ComplexNumber(a = 0.0, b = -1.0) (ComplexNumber(1, 0) / ComplexNumber(-2, 1)) / ComplexNumber(1, -3) // res12: ComplexNumber = ComplexNumber(a = 0.020000000000000007, b = -0.14) ComplexNumber(5, 6).abs // res13: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(-5, 6).abs // res14: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(5, -6).abs // res15: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(-5, -6).abs // res16: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(5, 6).conjugate // res17: ComplexNumber = ComplexNumber(a = 5.0, b = -6.0) ComplexNumber(5, 6).conjugate.conjugate // res18: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(5.0, 12.0).productWithConjugate // res19: Double = 169.0 ComplexNumber(5.0, 12.0).sqrt // res20: Array[ComplexNumber] = Array( // ComplexNumber(a = 3.0, b = 2.0), // ComplexNumber(a = 3.0, b = -2.0) // ) ComplexNumber(5.0, 3.0).power2 // res21: ComplexNumber = ComplexNumber(a = 16.0, b = 30.0) ComplexNumber(5.0, 3.0).power2.power2 // res22: ComplexNumber = ComplexNumber(a = -644.0, b = 960.0) ComplexNumber(5.0, 3.0).power2.power2.power2 // res23: ComplexNumber = ComplexNumber(a = -506864.0, b = -1236480.0) ComplexNumber(5.0, 3.0).power(8) // res24: ComplexNumber = ComplexNumber(a = -506864.0, b = -1236480.0) ComplexNumber(-1.0 / 2.0, Math.sqrt(3.0) / 2.0).power(3) // res25: ComplexNumber = ComplexNumber( // a = 0.9999999999999998, // b = 1.1102230246251565E-16 // )"
    } ,    
    {
      "title": "Cyclic numbers",
      "url": "/algorithms/docs/numbers/cyclic_numbers.html",
      "content": "The term figurate number is used by different writers for members of different sets of numbers, generalizing from triangular numbers to different shapes (polygonal numbers) and different dimensions (polyhedral numbers). figurateNumbers Algorithm Triangular number - Square number - Pentagonal number - Hexagonal number - Heptagonal number - Octagonal number - Complexity Sources Triangular number Square number Pentagonal number Hexagonal number Heptagonal number Octagonal number Using import com.github.artemkorsakov.numbers.CyclicNumbers._ (1 to 5).map(i =&gt; i.triangleNumber) // res0: IndexedSeq[Long] = Vector(1L, 3L, 6L, 10L, 15L) (1 to 5).map(i =&gt; i.squareNumber) // res1: IndexedSeq[Long] = Vector(1L, 4L, 9L, 16L, 25L) (1 to 5).map(i =&gt; i.pentagonalNumber) // res2: IndexedSeq[Long] = Vector(1L, 5L, 12L, 22L, 35L) (1 to 5).map(i =&gt; i.hexagonalNumber) // res3: IndexedSeq[Long] = Vector(1L, 6L, 15L, 28L, 45L) (1 to 5).map(i =&gt; i.heptagonalNumber) // res4: IndexedSeq[Long] = Vector(1L, 7L, 18L, 34L, 55L) (1 to 5).map(i =&gt; i.octagonalNumber) // res5: IndexedSeq[Long] = Vector(1L, 8L, 21L, 40L, 65L) 8256.isTriangle // res6: Boolean = true 5625.isSquare // res7: Boolean = true 2882.isPentagonal // res8: Boolean = true 8128.isHexagonal // res9: Boolean = true 2512.isHeptagonal // res10: Boolean = true 1281.isOctagonal // res11: Boolean = true"
    } ,    
    {
      "title": "Darts",
      "url": "/algorithms/docs/games/darts.html",
      "content": "In the game of darts a player throws three darts at a target board which is split into twenty equal sized sections numbered one to twenty. The score of a dart is determined by the number of the region that the dart lands in. A dart landing outside the red/green outer ring scores zero. The black and cream regions inside this ring represent single scores. However, the red/green outer ring and middle ring score double and treble scores respectively. At the centre of the board are two concentric circles called the bull region, or bulls-eye. The outer bull is worth 25 points and the inner bull is a double, worth 50 points. There are many variations of rules but in the most popular game the players will begin with a score 301 or 501 and the first player to reduce their running total to zero is a winner. However, it is normal to play a “doubles out” system, which means that the player must land a double (including the double bulls-eye at the centre of the board) on their final dart to win; any other dart that would reduce their running total to one or lower means the score for that set of three darts is “bust”. When a player is able to finish on their current score it is called a “checkout” and the highest checkout is 170: T20 T20 D25 (two treble 20s and double bull). There are exactly eleven distinct ways to checkout on a score of 6: D3 D1 D2 S2 D2 D2 D1 S4 D1 S1 S1 D2 S1 T1 D1 S1 S3 D1 D1 D1 D1 D1 S2 D1 S2 S2 D1 Note that D1 D2 is considered different to D2 D1 as they finish on different doubles. However, the combination S1 T1 D1 is considered the same as T1 S1 D1. In addition we shall not include misses in considering combinations; for example, D3 is the same as 0 D3 and 0 0 D3. allDistinctWaysToCheckOut How many distinct ways can a player checkout with the given score? Algorithm Complexity Sources Project Euler. Problem 109 Using import com.github.artemkorsakov.games.darts.Darts Darts.allDistinctWaysToCheckOut(6) // res0: Int = 11 Darts.allDistinctWaysToCheckOut.values.sum // res1: Int = 42336"
    } ,    
    {
      "title": "Dice game",
      "url": "/algorithms/docs/games/dice.html",
      "content": "List of dice games probabilities An array of probabilities to get the given sums from the cube with the maximum face maxCube and for a given count of steps. Algorithm Complexity Sources Project Euler. Problem 205 Using import com.github.artemkorsakov.games.dice.Dice Dice(6).probabilities(1).zipWithIndex.map(rnwi =&gt; s\"The chance of getting ${rnwi._2 + 1} in 1 steps is ${rnwi._1.toPercent}\") // res0: Seq[String] = Vector( // \"The chance of getting 1 in 1 steps is 0.16666666666666666\", // \"The chance of getting 2 in 1 steps is 0.16666666666666666\", // \"The chance of getting 3 in 1 steps is 0.16666666666666666\", // \"The chance of getting 4 in 1 steps is 0.16666666666666666\", // \"The chance of getting 5 in 1 steps is 0.16666666666666666\", // \"The chance of getting 6 in 1 steps is 0.16666666666666666\" // ) Dice(6).probabilities(2).zipWithIndex.map(rnwi =&gt; s\"The chance of getting ${rnwi._2 + 1} in 2 steps is ${rnwi._1.toPercent}\") // res1: Seq[String] = Vector( // \"The chance of getting 1 in 2 steps is 0.0\", // \"The chance of getting 2 in 2 steps is 0.027777777777777776\", // \"The chance of getting 3 in 2 steps is 0.05555555555555555\", // \"The chance of getting 4 in 2 steps is 0.08333333333333333\", // \"The chance of getting 5 in 2 steps is 0.1111111111111111\", // \"The chance of getting 6 in 2 steps is 0.1388888888888889\", // \"The chance of getting 7 in 2 steps is 0.16666666666666666\", // \"The chance of getting 8 in 2 steps is 0.1388888888888889\", // \"The chance of getting 9 in 2 steps is 0.1111111111111111\", // \"The chance of getting 10 in 2 steps is 0.08333333333333333\", // \"The chance of getting 11 in 2 steps is 0.05555555555555555\", // \"The chance of getting 12 in 2 steps is 0.027777777777777776\" // ) Dice(6).probabilities(3).zipWithIndex.map(rnwi =&gt; s\"The chance of getting ${rnwi._2 + 1} in 3 steps is ${rnwi._1.toPercent}\") // res2: Seq[String] = Vector( // \"The chance of getting 1 in 3 steps is 0.0\", // \"The chance of getting 2 in 3 steps is 0.0\", // \"The chance of getting 3 in 3 steps is 0.004629629629629629\", // \"The chance of getting 4 in 3 steps is 0.013888888888888888\", // \"The chance of getting 5 in 3 steps is 0.027777777777777776\", // \"The chance of getting 6 in 3 steps is 0.046296296296296294\", // \"The chance of getting 7 in 3 steps is 0.06944444444444445\", // \"The chance of getting 8 in 3 steps is 0.09722222222222222\", // \"The chance of getting 9 in 3 steps is 0.11574074074074074\", // \"The chance of getting 10 in 3 steps is 0.125\", // \"The chance of getting 11 in 3 steps is 0.125\", // \"The chance of getting 12 in 3 steps is 0.11574074074074074\", // \"The chance of getting 13 in 3 steps is 0.09722222222222222\", // \"The chance of getting 14 in 3 steps is 0.06944444444444445\", // \"The chance of getting 15 in 3 steps is 0.046296296296296294\", // \"The chance of getting 16 in 3 steps is 0.027777777777777776\", // \"The chance of getting 17 in 3 steps is 0.013888888888888888\", // \"The chance of getting 18 in 3 steps is 0.004629629629629629\" // )"
    } ,    
    {
      "title": "Digital",
      "url": "/algorithms/docs/digital.html",
      "content": "Digital The package com.github.artemkorsakov.digital contains operations with digits of a given number. You can use the package, for example, like this: import com.github.artemkorsakov.digital.Digits._ containTheSameDigits(127035954683L, 589323567104L) // res0: Boolean = true 1406357289L.digits // res1: Array[Int] = Array(1, 4, 0, 6, 3, 5, 7, 2, 8, 9) 1406357289L.sumOfDigits // res2: Int = 45 56993.hasEqualDigits // res3: Boolean = true 56993.hasEqualDigits(2, 9) // res4: Boolean = true 56993.hasEqualDigits(3, 9) // res5: Boolean = false possibleNumbers(IndexedSeq(1, 1, 5, 6)) // res6: Set[String] = HashSet( // \"1165\", // \"6511\", // \"1156\", // \"5161\", // \"6151\", // \"1615\", // \"5611\", // \"6115\", // \"5116\", // \"1516\", // \"1651\", // \"1561\" // ) import com.github.artemkorsakov.digital.Pandigital._ 192384576L.isPandigital // res8: Boolean = true 2134.isPandigital(4) // res9: Boolean = true 1406357289L.isPandigital(Array(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)) // res10: Boolean = true"
    } ,    
    {
      "title": "Digits",
      "url": "/algorithms/docs/digital/digits.html",
      "content": "containTheSameDigits Do two numbers contain the same digits? It is the same as Operations with strings - areAnagrams Algorithm Complexity Sources Using import com.github.artemkorsakov.digital.Digits._ containTheSameDigits(127035954683L, 589323567104L) // res0: Boolean = true digits Returns the digits of a number. Algorithm Complexity Sources Using 1406357289L.digits // res1: Array[Int] = Array(1, 4, 0, 6, 3, 5, 7, 2, 8, 9) sumOfDigits Returns the sum of the digits of a number. Algorithm Complexity Sources Using 1406357289L.sumOfDigits // res2: Int = 45 hasEqualDigits Does the number have at least two of the same digits? Algorithm Complexity Sources Using 56993.hasEqualDigits // res3: Boolean = true 56993.hasEqualDigits(2, 9) // res4: Boolean = true 56993.hasEqualDigits(3, 9) // res5: Boolean = false possibleNumbers Returns all numbers made up of given digits. Algorithm Complexity Sources Using possibleNumbers(IndexedSeq(1, 1, 5, 6)) // res6: Set[String] = HashSet( // \"1165\", // \"6511\", // \"1156\", // \"5161\", // \"6151\", // \"1615\", // \"5611\", // \"6115\", // \"5116\", // \"1516\", // \"1651\", // \"1561\" // )"
    } ,    
    {
      "title": "Diophantine equation",
      "url": "/algorithms/docs/equations/diophantine_equation.html",
      "content": "Solving an equation x2 – D*y2 = 1 by Chakravala method. minimalEquation Algorithm Complexity Sources Chakravala method Using import com.github.artemkorsakov.equations.DiophantineEquation DiophantineEquation(61).minimalEquation // res0: Option[(BigInt, BigInt)] = Some(value = (1766319049, 226153980))"
    } ,    
    {
      "title": "Divisors",
      "url": "/algorithms/docs/divisors.html",
      "content": "Divisors The package com.github.artemkorsakov.divisors contains operations with divisors of a given number. You can use the package, for example, like this: import com.github.artemkorsakov.divisors.Divisors._ gcd(12121212L, 23422344L) // res0: Long = 12L gcdex(12121212L, 23422344L) // res1: (Long, Long, Long) = (12L, 347845L, -180012L) gcdInverse(111, 10) // res2: Long = 1L 30.divisors // res3: Set[Long] = HashSet(5L, 10L, 6L, 2L, 3L, 15L) 220.sumOfDivisors // res4: BigInt = 504 100.countOfDivisors // res5: Long = 9L import com.github.artemkorsakov.divisors.ChineseRemainderTheorem ChineseRemainderTheorem.solution(Array(707, 527), Array(0, 5)) // res6: BigInt = 258762 import com.github.artemkorsakov.divisors.PerfectNumbers._ 8128.perfectNumbersType // res7: PerfectNumbersType = Perfect"
    } ,    
    {
      "title": "Operations with divisors",
      "url": "/algorithms/docs/divisors/divisors_oper.html",
      "content": "Common operations with divisors. gcd Return the greatest common divisor. Algorithm gcd(0, v) = v, because everything divides zero, and v is the largest number that divides v. Similarly, gcd(u, 0) = u. gcd(2u, 2v) = 2·gcd(u, v) gcd(2u, v) = gcd(u, v), if v is odd (2 is not a common divisor). Similarly, gcd(u, 2v) = gcd(u, v) if u is odd. gcd(u, v) = gcd(abs(u − v), min(u, v)), if u and v are both odd. Complexity Sources Binary GCD algorithm Using import com.github.artemkorsakov.divisors.Divisors._ gcd(12121212L, 23422344L) // res0: Long = 12L gcdex In arithmetic and computer programming, the extended Euclidean algorithm is an extension to the Euclidean algorithm, and computes, in addition to the greatest common divisor of integers a and b, also the coefficients of Bézout’s identity, which are integers x and y such that The result is a tuple (gcd(a,b), x, y) Algorithm Complexity Sources Extended Euclidean algorithm Using gcdex(12121212L, 23422344L) // res1: (Long, Long, Long) = (12L, 347845L, -180012L) gcdInverse In mathematics, particularly in the area of number theory, a modular multiplicative inverse of an integer a is an integer x such that the product ax is congruent to 1 with respect to the modulus m. In the standard notation of modular arithmetic this congruence is written as Algorithm Complexity Sources Modular multiplicative inverse Using gcdInverse(111, 10) // res2: Long = 1L divisors Returns all divisors of n (more than 1 and less than n). Algorithm Complexity Sources Using 30.divisors // res3: Set[Long] = HashSet(5L, 10L, 6L, 2L, 3L, 15L) sumOfDivisors Return the sum of the divisors of n. Algorithm If we write where r = ω(n) is the number of distinct prime factors of n, pi is the ith prime factor, and ai is the maximum power of pi by which n is divisible, then we have: Complexity Sources Divisor function Using 220.sumOfDivisors // res4: BigInt = 504 countOfDivisors Return the count of divisors of n. Algorithm If we write where r = ω(n) is the number of distinct prime factors of n, pi is the ith prime factor, and ai is the maximum power of pi by which n is divisible, then we have: Complexity Sources Divisor function Using 100.countOfDivisors // res5: Long = 9L"
    } ,    
    {
      "title": "Equations",
      "url": "/algorithms/docs/equations.html",
      "content": "Equations The package com.github.artemkorsakov.equations contains algorithms for solving equations. You can use the package, for example, like this: import com.github.artemkorsakov.equations._ QuadraticEquation(1, -5, -6).solutionsInIntegers // res0: Seq[Long] = List(6L, -1L) QuadraticEquation(1, -5, 5).solutions // res1: Seq[Double] = List(3.618033988749895, 1.381966011250105) QuadraticEquation(1, -2, 2).solutionsInComplexNumbers // res2: Seq[com.github.artemkorsakov.numbers.ComplexNumber] = List( // ComplexNumber(a = 1.0, b = 1.0), // ComplexNumber(a = 1.0, b = -1.0) // ) import com.github.artemkorsakov.equations.DiophantineEquation DiophantineEquation(61).minimalEquation // res3: Option[(BigInt, BigInt)] = Some(value = (1766319049, 226153980)) import com.github.artemkorsakov.equations.PolynomialEquation PolynomialEquation.polynomialCoefficients(3, Array(1, 8, 27)) // res4: Array[Long] = Array(6L, -11L, 6L)"
    } ,    
    {
      "title": "Factorials",
      "url": "/algorithms/docs/combinatorics/factorials.html",
      "content": "Factorial factorial Calculate factorial. Algorithm Complexity O(n) Sources Wikipedia Using import com.github.artemkorsakov.combinatorics.Factorials._ 30.factorial // res0: BigInt = 265252859812191058636308480000000"
    } ,    
    {
      "title": "Fibonacci",
      "url": "/algorithms/docs/numbers/fibonacci.html",
      "content": "In mathematics, the Fibonacci numbers, commonly denoted Fn, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F0=0, F1=1 and Fn=Fn-1+Fn-2 for n &gt; 1. The beginning of the sequence is thus: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … fibonacci Algorithm Complexity Sources Fibonacci number Using import com.github.artemkorsakov.numbers.Fibonacci._ (1 to 6).map(i =&gt; i.fibonacci) // res0: IndexedSeq[BigInt] = Vector(1, 1, 2, 3, 5, 8) 100.fibonacci // res1: BigInt = 354224848179265190133 fibonacciMatrix Algorithm Complexity Sources Fibonacci number Using 20.fibonacciMatrix // res2: Option[Seq[Seq[BigInt]]] = Some( // value = List(List(10946, 6765), List(6765, 4181)) // ) 1000000000000000L.fibonacciMatrix(1307674368000L) // res3: Option[Seq[Seq[BigInt]]] = Some( // value = List(List(73179529501, 36651874875), List(36651874875, 36527654626)) // )"
    } ,    
    {
      "title": "Games",
      "url": "/algorithms/docs/games.html",
      "content": "Games The package com.github.artemkorsakov.games contains algorithms for different games. You can use the package, for example, like this: import com.github.artemkorsakov.games.dice.Dice Dice(6).probabilities(1).zipWithIndex.map(rnwi =&gt; s\"The chance of getting ${rnwi._2 + 1} in 1 steps is ${rnwi._1.toPercent}\") // res0: Seq[String] = Vector( // \"The chance of getting 1 in 1 steps is 0.16666666666666666\", // \"The chance of getting 2 in 1 steps is 0.16666666666666666\", // \"The chance of getting 3 in 1 steps is 0.16666666666666666\", // \"The chance of getting 4 in 1 steps is 0.16666666666666666\", // \"The chance of getting 5 in 1 steps is 0.16666666666666666\", // \"The chance of getting 6 in 1 steps is 0.16666666666666666\" // ) Dice(6).probabilities(2).zipWithIndex.map(rnwi =&gt; s\"The chance of getting ${rnwi._2 + 1} in 2 steps is ${rnwi._1.toPercent}\") // res1: Seq[String] = Vector( // \"The chance of getting 1 in 2 steps is 0.0\", // \"The chance of getting 2 in 2 steps is 0.027777777777777776\", // \"The chance of getting 3 in 2 steps is 0.05555555555555555\", // \"The chance of getting 4 in 2 steps is 0.08333333333333333\", // \"The chance of getting 5 in 2 steps is 0.1111111111111111\", // \"The chance of getting 6 in 2 steps is 0.1388888888888889\", // \"The chance of getting 7 in 2 steps is 0.16666666666666666\", // \"The chance of getting 8 in 2 steps is 0.1388888888888889\", // \"The chance of getting 9 in 2 steps is 0.1111111111111111\", // \"The chance of getting 10 in 2 steps is 0.08333333333333333\", // \"The chance of getting 11 in 2 steps is 0.05555555555555555\", // \"The chance of getting 12 in 2 steps is 0.027777777777777776\" // ) Dice(6).probabilities(3).zipWithIndex.map(rnwi =&gt; s\"The chance of getting ${rnwi._2 + 1} in 3 steps is ${rnwi._1.toPercent}\") // res2: Seq[String] = Vector( // \"The chance of getting 1 in 3 steps is 0.0\", // \"The chance of getting 2 in 3 steps is 0.0\", // \"The chance of getting 3 in 3 steps is 0.004629629629629629\", // \"The chance of getting 4 in 3 steps is 0.013888888888888888\", // \"The chance of getting 5 in 3 steps is 0.027777777777777776\", // \"The chance of getting 6 in 3 steps is 0.046296296296296294\", // \"The chance of getting 7 in 3 steps is 0.06944444444444445\", // \"The chance of getting 8 in 3 steps is 0.09722222222222222\", // \"The chance of getting 9 in 3 steps is 0.11574074074074074\", // \"The chance of getting 10 in 3 steps is 0.125\", // \"The chance of getting 11 in 3 steps is 0.125\", // \"The chance of getting 12 in 3 steps is 0.11574074074074074\", // \"The chance of getting 13 in 3 steps is 0.09722222222222222\", // \"The chance of getting 14 in 3 steps is 0.06944444444444445\", // \"The chance of getting 15 in 3 steps is 0.046296296296296294\", // \"The chance of getting 16 in 3 steps is 0.027777777777777776\", // \"The chance of getting 17 in 3 steps is 0.013888888888888888\", // \"The chance of getting 18 in 3 steps is 0.004629629629629629\" // ) import com.github.artemkorsakov.games.darts.Darts Darts.allDistinctWaysToCheckOut(6) // res3: Int = 11 Darts.allDistinctWaysToCheckOut.values.sum // res4: Int = 42336 import com.github.artemkorsakov.games.nim.Nim Nim.getX(1, 2, 3) // res5: Long = 0L import com.github.artemkorsakov.games.poker.Poker // Pair of Fives, Pair of Eights Poker(\"5H 5C 6S 7S KD\", \"2C 3S 8S 8D TD\").doesPlayer1Win // res6: Boolean = false // Highest card Ace, Highest card Queen Poker(\"5D 8C 9S JS AC\", \"2C 5C 7D 8S QH\").doesPlayer1Win // res7: Boolean = true // Three Aces, Flush with Diamonds Poker(\"2D 9C AS AH AC\", \"3D 6D 7D TD QD\").doesPlayer1Win // res8: Boolean = false // Pair of Queens Highest card Nine, Pair of Queens Highest card Seven Poker(\"4D 6S 9H QH QC\", \"3D 6D 7H QD QS\").doesPlayer1Win // res9: Boolean = true // Full House With Three Fours, Full House with Three Threes Poker(\"2H 2D 4C 4D 4S\", \"3C 3D 3S 9S 9D\").doesPlayer1Win // res10: Boolean = true import com.github.artemkorsakov.games.sudoku.SuDoku._ val src = \"003020600\\n900305001\\n001806400\\n008102900\\n700000008\\n006708200\\n002609500\\n800203009\\n005010300\" // src: String = \"\"\"003020600 // 900305001 // 001806400 // 008102900 // 700000008 // 006708200 // 002609500 // 800203009 // 005010300\"\"\" toSuDoku(src).get.result.foreach(_.foreach(row =&gt; println(row.mkString(\"|\", \"\", \"|\")))) // |483921657| // |967345821| // |251876493| // |548132976| // |729564138| // |136798245| // |372689514| // |814253769| // |695417382|"
    } ,    
    {
      "title": "Hamming number",
      "url": "/algorithms/docs/numbers/hamming.html",
      "content": "A positive number is a generalised Hamming number of type n, if it has no prime factor larger than n. isHammingNumber Algorithm Complexity Sources Using import com.github.artemkorsakov.numbers.HammingNumber._ 2125764000.isHammingNumber(5) // res0: Boolean = true 2125764000.isHammingNumber(7) // res1: Boolean = true 2125764000.isHammingNumber(3) // res2: Boolean = false"
    } ,    
    {
      "title": "Harshad number",
      "url": "/algorithms/docs/numbers/harshad.html",
      "content": "A harshad number is an integer that is divisible by the sum of its digits. A strong Harshad number is a harshad number that, when divided by the sum of its digits, results in a prime. isHarshadNumber A harshad number is an integer that is divisible by the sum of its digits. Algorithm Complexity Sources Using import com.github.artemkorsakov.numbers.HarshadNumber._ 1728.isHarshadNumber // res0: Boolean = true 1729.isHarshadNumber // res1: Boolean = true 1730.isHarshadNumber // res2: Boolean = false isStrongHarshadNumber A strong Harshad number is a harshad number that, when divided by the sum of its digits, results in a prime. Algorithm Complexity Sources Using 198.isStrongHarshadNumber // res3: Boolean = true 1728.isStrongHarshadNumber // res4: Boolean = false 1729.isStrongHarshadNumber // res5: Boolean = false getStrongRightTruncatableHarshadPrimes A Harshad or Niven number is a number that is divisible by the sum of its digits. 201 is a Harshad number because it is divisible by 3 (the sum of its digits.) When we truncate the last digit from 201, we get 20, which is a Harshad number. When we truncate the last digit from 20, we get 2, which is also a Harshad number. Let’s call a Harshad number that, while recursively truncating the last digit, always results in a Harshad number a right truncatable Harshad number. Also: 201/3=67 which is prime. Let’s call a Harshad number that, when divided by the sum of its digits, results in a prime a strong Harshad number. Now take the number 2011 which is prime. When we truncate the last digit from it we get 201, a strong Harshad number that is also right truncatable. Let’s call such primes strong, right truncatable Harshad primes. Return all strong, right truncatable Harshad primes less than 10p. Algorithm Complexity Sources Project Euler. Problem 387 Using getStrongRightTruncatableHarshadPrimes(3) // res6: Seq[Long] = Vector(181L, 211L, 271L, 277L, 421L, 457L, 631L) getStrongRightTruncatableHarshadPrimes(4).sum // res7: Long = 90619L"
    } ,    
    {
      "title": "Introduction",
      "url": "/algorithms/docs/",
      "content": "Introduction Algorithms library contains the most popular and interesting algorithms. The following books, articles and resources served as a source for the algorithms - source of algorithms Installation The library is available in the central repository - It is available on scala 2.13, 2.12. Add the following to your build.sbt libraryDependencies += \"com.github.artemkorsakov\" %% \"algorithms-core\" % \"0.1.2\""
    } ,    
    {
      "title": "Home",
      "url": "/algorithms/",
      "content": "Home Overview Algorithms library contains the most popular and interesting algorithms. Please email, create an issue or pull request on github in the following cases: you found an error in an algorithm or on the website you think that an algorithm is not efficient and there is a better implementation you want to add a new algorithm any other case that you consider important In addition, Improve this Page button is available on the documentation pages Getting Started Add the following to your build.sbt libraryDependencies += \"com.github.artemkorsakov\" %% \"algorithms-core\" % \"0.1.2\" Documentation Documentation ScalaDoc"
    } ,    
    {
      "title": "Matrix",
      "url": "/algorithms/docs/objects/matrix.html",
      "content": "Matrix. mulRows Product of two lines. Algorithm Complexity Sources Using import com.github.artemkorsakov.objects.MatrixLine._ Seq(1L, 2L, -3L).mul(Seq(-7L, 4L, 6L)) // res0: Option[Long] = Some(value = -17L) Seq(1L, 2L, -3L) * Seq(-7L, 4L, 6L) // res1: Option[Long] = Some(value = -17L) Seq(1007, 2456, -3466).mulMod(Seq(-3347, 4343, 6445), 1000) // res2: Option[Int] = Some(value = 609) matrixTranspose Transpose of a matrix. Algorithm Complexity Sources Transpose Using import com.github.artemkorsakov.objects.Matrix._ Seq(Seq(1, 2), Seq(3, 4), Seq(5, 6)).matrixTranspose // res3: Seq[Seq[Int]] = Vector(Vector(1, 3, 5), Vector(2, 4, 6)) Seq(Seq(1, 3, 5), Seq(2, 4, 6)).matrixTranspose // res4: Seq[Seq[Int]] = Vector(Vector(1, 2), Vector(3, 4), Vector(5, 6)) Seq(Seq(1, 2), Seq(3, 4), Seq(5, 6)).matrixTranspose.matrixTranspose // res5: Seq[Seq[Int]] = Vector(Vector(1, 2), Vector(3, 4), Vector(5, 6)) minorMatrix New matrix without the given row and the given column. Algorithm Complexity Sources Using Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).minorMatrix(1, 2) // res6: Option[Seq[Seq[Int]]] = Some( // value = Vector(Vector(-2, -1, -4), Vector(-1, -1, 4), Vector(2, 1, -8)) // ) matrixDeterminant Determinant of a matrix. Algorithm Complexity Sources Determinant Using Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).matrixDeterminant // res7: Option[Int] = Some(value = -8) add Addition of two matrices. Algorithm Complexity Sources Using val matrixA = Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)) // matrixA: Seq[Seq[Int]] = List( // List(-2, -1, -1, -4), // List(-1, -2, -1, -6), // List(-1, -1, 2, 4), // List(2, 1, -3, -8) // ) val matrixB = Seq(Seq(8, -5, -6, -4), Seq(-13, -22, -11, -65), Seq(45, 45, 34, 35), Seq(23, 12, -33, -82)) // matrixB: Seq[Seq[Int]] = List( // List(8, -5, -6, -4), // List(-13, -22, -11, -65), // List(45, 45, 34, 35), // List(23, 12, -33, -82) // ) matrixA.add(matrixB) // res8: Option[Seq[Seq[Int]]] = Some( // value = Vector( // Vector(6, -6, -7, -8), // Vector(-14, -24, -12, -71), // Vector(44, 44, 36, 39), // Vector(25, 13, -36, -90) // ) // ) matrixA + matrixB // res9: Option[Seq[Seq[Int]]] = Some( // value = Vector( // Vector(6, -6, -7, -8), // Vector(-14, -24, -12, -71), // Vector(44, 44, 36, 39), // Vector(25, 13, -36, -90) // ) // ) mulByNum Matrix multiplication by number. Algorithm Complexity Sources Using Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).mul(7) // res10: Seq[Seq[Int]] = Vector( // Vector(-14, -7, -7, -28), // Vector(-7, -14, -7, -42), // Vector(-7, -7, 14, 28), // Vector(14, 7, -21, -56) // ) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)) * 8 // res11: Seq[Seq[Int]] = Vector( // Vector(-16, -8, -8, -32), // Vector(-8, -16, -8, -48), // Vector(-8, -8, 16, 32), // Vector(16, 8, -24, -64) // ) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).mulMod(10, 11) // res12: Seq[Seq[Int]] = Vector( // Vector(2, 1, 1, 4), // Vector(1, 2, 1, 6), // Vector(1, 1, 9, 7), // Vector(9, 10, 3, 8) // ) mulMatrix Matrix multiplication. Algorithm Complexity Sources Using Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mul(Seq(Seq(1, 2, 3), Seq(-3, 5, 4), Seq(6, 2, 1), Seq(1, -1, 0))) // res13: Option[Seq[Seq[Int]]] = Some( // value = List(List(8, 25, 27), List(23, -1, -1), List(13, 18, 14)) // ) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)) * Seq(Seq(1, 2, 3), Seq(-3, 5, 4), Seq(6, 2, 1), Seq(1, -1, 0)) // res14: Option[Seq[Seq[Int]]] = Some( // value = List(List(8, 25, 27), List(23, -1, -1), List(13, 18, 14)) // ) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mulMod(Seq(Seq(1, 2, 3), Seq(-3, 5, 4), Seq(6, 2, 1), Seq(1, -1, 0)), 7) // res15: Option[Seq[Seq[Int]]] = Some( // value = List(List(1, 4, 6), List(2, 6, 6), List(6, 4, 0)) // ) mulMatrixByRow Matrix multiplication by row. Algorithm Complexity Sources Using Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mul(Seq(1, -3, 6, 1)) // res16: Option[Seq[Int]] = Some(value = List(8, 23, 13)) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)) * Seq(1, -3, 6, 1) // res17: Option[Seq[Int]] = Some(value = List(8, 23, 13)) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mulMod(Seq(1, -3, 6, 1), 7) // res18: Option[Seq[Int]] = Some(value = List(1, 2, 6)) Seq(1, -3, 6).mul(Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0))) // res19: Option[Seq[Int]] = Some(value = List(9, 19, 11, -1)) Seq(1, -3, 6) * Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)) // res20: Option[Seq[Int]] = Some(value = List(9, 19, 11, -1)) Seq(1, -3, 6).mulMod(Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)), 7) // res21: Option[Seq[Int]] = Some(value = List(2, 5, 4, 6)) power Matrix exponentiation. Algorithm Complexity Sources Using Seq(Seq(2, 0), Seq(-1, 3)).power(2) // res22: Option[Seq[Seq[Int]]] = Some(value = List(List(4, 0), List(-5, 9))) val fibonacciMatrix = Seq(Seq(1, 1), Seq(1, 0)) // fibonacciMatrix: Seq[Seq[Int]] = List(List(1, 1), List(1, 0)) fibonacciMatrix.power(20) // res23: Option[Seq[Seq[Int]]] = Some( // value = List(List(10946, 6765), List(6765, 4181)) // ) Seq(Seq(1, 2, 1, 0), Seq(1, 1, 0, -1), Seq(-2, 0, 1, 2), Seq(0, 2, 1, 1)).power(100) // res24: Option[Seq[Seq[Int]]] = Some( // value = List( // List(1, 200, 100, 0), // List(100, 1, 0, -100), // List(-200, 0, 1, 200), // List(0, 200, 100, 1) // ) // ) fibonacciMatrix.powerMod(50, 1000000) // res25: Option[Seq[Seq[Int]]] = Some( // value = List(List(11074, 269025), List(269025, 742049)) // )"
    } ,    
    {
      "title": "Nim",
      "url": "/algorithms/docs/games/nim.html",
      "content": "Nim is a game played with heaps of stones, where two players take it in turn to remove any number of stones from any heap until no stones remain. We’ll consider the three-heap normal-play version of Nim, which works as follows: At the start of the game there are three heaps of stones. On each player’s turn, the player may remove any positive number of stones from any single heap. The first player unable to move (because no stones remain) loses. If (n1, n2, n3) indicates a Nim position consisting of heaps of size n1, n2, and n3, then there is a simple function, which you may look up or attempt to deduce for yourself, X(n1, n2, n3) that returns: zero if, with perfect strategy, the player about to move will eventually lose; or non-zero if, with perfect strategy, the player about to move will eventually win. For example X(1, 2, 3) = 0 because, no matter what the current player does, the opponent can respond with a move that leaves two heaps of equal size, at which point every move by the current player can be mirrored by the opponent until no stones remain; so the current player loses. To illustrate: current player moves to (1, 2, 1) opponent moves to (1, 0, 1) current player moves to (0, 0, 1) opponent moves to (0, 0, 0), and so wins. getX Return X(n1, n2, n3). Algorithm Complexity Sources Nim Project Euler. Problem 301 Using import com.github.artemkorsakov.games.nim.Nim Nim.getX(1, 2, 3) // res0: Long = 0L"
    } ,    
    {
      "title": "Various numbers",
      "url": "/algorithms/docs/numbers.html",
      "content": "Various numbers The package com.github.artemkorsakov.numbers contains various numbers. You can use the package, for example, like this: import com.github.artemkorsakov.numbers.RationalNumber import com.github.artemkorsakov.numbers.RationalNumber._ val x = new RationalNumber(1, 3) // x: RationalNumber = 1/3 val y = new RationalNumber(5, 7) // y: RationalNumber = 5/7 x.add(y) // res0: RationalNumber = 22/21 x.sub(y) // res1: RationalNumber = -8/21 x.mul(y) // res2: RationalNumber = 5/21 x.div(y) // res3: RationalNumber = 7/15 x + y // res4: RationalNumber = 22/21 x - y // res5: RationalNumber = -8/21 x * y // res6: RationalNumber = 5/21 x / y // res7: RationalNumber = 7/15 x.upend // res8: RationalNumber = 3/1 y.upend // res9: RationalNumber = 7/5 x.equal(new RationalNumber(1, 3)) // res10: Boolean = true x.equal(new RationalNumber(-2, -6)) // res11: Boolean = true x.equal(new RationalNumber(3, 9)) // res12: Boolean = true x.equal(new RationalNumber(1, 4)) // res13: Boolean = false x == new RationalNumber(1, 3) // res14: Boolean = true x == new RationalNumber(-2, -6) // res15: Boolean = true x == new RationalNumber(3, 9) // res16: Boolean = true x == new RationalNumber(1, 4) // res17: Boolean = false x &lt; y // res18: Boolean = true y &lt; x // res19: Boolean = false x &lt; x // res20: Boolean = false x &lt;= y // res21: Boolean = true x &lt;= x // res22: Boolean = true x &gt; y // res23: Boolean = false y &gt; x // res24: Boolean = true x &gt; x // res25: Boolean = false x &gt;= y // res26: Boolean = false x &gt;= x // res27: Boolean = true max(x, y) == y // res28: Boolean = true max(x, x) == x // res29: Boolean = true max(y, y) == y // res30: Boolean = true new RationalNumber(5, 7).toPercent // res31: Double = 0.7142857142857143 import com.github.artemkorsakov.numbers.ComplexNumber ComplexNumber(2, 3).add(ComplexNumber(1, 4)) // res32: ComplexNumber = ComplexNumber(a = 3.0, b = 7.0) ComplexNumber(2, 3) + ComplexNumber(1, 4) // res33: ComplexNumber = ComplexNumber(a = 3.0, b = 7.0) ComplexNumber(2, 3).sub(ComplexNumber(1, 4)) // res34: ComplexNumber = ComplexNumber(a = 1.0, b = -1.0) ComplexNumber(2, 3) - ComplexNumber(1, 4) // res35: ComplexNumber = ComplexNumber(a = 1.0, b = -1.0) ComplexNumber(2, 3).mul(ComplexNumber(1, 4)) // res36: ComplexNumber = ComplexNumber(a = -10.0, b = 11.0) ComplexNumber(2, 3) * ComplexNumber(1, 4) // res37: ComplexNumber = ComplexNumber(a = -10.0, b = 11.0) ComplexNumber(2, 3).div(ComplexNumber(1, 4)) // res38: ComplexNumber = ComplexNumber( // a = 0.8235294117647058, // b = -0.29411764705882354 // ) ComplexNumber(2, 3) / ComplexNumber(1, 4) // res39: ComplexNumber = ComplexNumber( // a = 0.8235294117647058, // b = -0.29411764705882354 // ) (ComplexNumber(1, 1) * ComplexNumber(2, 1) * ComplexNumber(3, 1)) / ComplexNumber(1, -1) // res40: ComplexNumber = ComplexNumber(a = -5.0, b = 5.0) ComplexNumber(1, 1) / ComplexNumber(1, -1) // res41: ComplexNumber = ComplexNumber(a = 0.0, b = 1.0) ComplexNumber(1, 1) / ComplexNumber(2, -1) // res42: ComplexNumber = ComplexNumber(a = 0.2, b = 0.6) ComplexNumber(1, 0) / ComplexNumber(0, 1) // res43: ComplexNumber = ComplexNumber(a = 0.0, b = -1.0) (ComplexNumber(1, 0) / ComplexNumber(-2, 1)) / ComplexNumber(1, -3) // res44: ComplexNumber = ComplexNumber(a = 0.020000000000000007, b = -0.14) ComplexNumber(5, 6).abs // res45: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(-5, 6).abs // res46: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(5, -6).abs // res47: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(-5, -6).abs // res48: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(5, 6).conjugate // res49: ComplexNumber = ComplexNumber(a = 5.0, b = -6.0) ComplexNumber(5, 6).conjugate.conjugate // res50: ComplexNumber = ComplexNumber(a = 5.0, b = 6.0) ComplexNumber(5.0, 12.0).productWithConjugate // res51: Double = 169.0 ComplexNumber(5.0, 12.0).sqrt // res52: Array[ComplexNumber] = Array( // ComplexNumber(a = 3.0, b = 2.0), // ComplexNumber(a = 3.0, b = -2.0) // ) ComplexNumber(5.0, 3.0).power2 // res53: ComplexNumber = ComplexNumber(a = 16.0, b = 30.0) ComplexNumber(5.0, 3.0).power2.power2 // res54: ComplexNumber = ComplexNumber(a = -644.0, b = 960.0) ComplexNumber(5.0, 3.0).power2.power2.power2 // res55: ComplexNumber = ComplexNumber(a = -506864.0, b = -1236480.0) ComplexNumber(5.0, 3.0).power(8) // res56: ComplexNumber = ComplexNumber(a = -506864.0, b = -1236480.0) ComplexNumber(-1.0 / 2.0, Math.sqrt(3.0) / 2.0).power(3) // res57: ComplexNumber = ComplexNumber( // a = 0.9999999999999998, // b = 1.1102230246251565E-16 // ) import com.github.artemkorsakov.numbers.Fibonacci._ (1 to 6).map(i =&gt; i.fibonacci) // res58: IndexedSeq[BigInt] = Vector(1, 1, 2, 3, 5, 8) 100.fibonacci // res59: BigInt = 354224848179265190133 20.fibonacciMatrix // res60: Option[Seq[Seq[BigInt]]] = Some( // value = List(List(10946, 6765), List(6765, 4181)) // ) 1000000000000000L.fibonacciMatrix(1307674368000L) // res61: Option[Seq[Seq[BigInt]]] = Some( // value = List(List(73179529501, 36651874875), List(36651874875, 36527654626)) // ) import com.github.artemkorsakov.numbers.HammingNumber._ 2125764000.isHammingNumber(5) // res62: Boolean = true 2125764000.isHammingNumber(7) // res63: Boolean = true 2125764000.isHammingNumber(3) // res64: Boolean = false import com.github.artemkorsakov.numbers.HarshadNumber._ 1728.isHarshadNumber // res65: Boolean = true 1729.isHarshadNumber // res66: Boolean = true 1730.isHarshadNumber // res67: Boolean = false 198.isStrongHarshadNumber // res68: Boolean = true 1728.isStrongHarshadNumber // res69: Boolean = false 1729.isStrongHarshadNumber // res70: Boolean = false getStrongRightTruncatableHarshadPrimes(3) // res71: Seq[Long] = Vector(181L, 211L, 271L, 277L, 421L, 457L, 631L) getStrongRightTruncatableHarshadPrimes(4).sum // res72: Long = 90619L import com.github.artemkorsakov.numbers.CollatzNumber._ 1.collatz // res73: Int = 0 3.collatz // res74: Int = 7 19.collatz // res75: Int = 20 27.collatz // res76: Int = 111 import com.github.artemkorsakov.numbers.Palindrome._ BigInt(\"4668731596684224866951378664\").isPalindrome // res77: Boolean = true 4994.isPalindrome // res78: Boolean = true 4994.isPalindrome(2) // res79: Boolean = false 15.isPalindrome(2) // res80: Boolean = true 26.isPalindrome(3) // res81: Boolean = true 63.isPalindrome(4) // res82: Boolean = true import com.github.artemkorsakov.numbers.PythagoreanDeuce._ import com.github.artemkorsakov.numbers.PythagoreanTriplet._ primitivePythagoreanDeuce // res83: com.github.artemkorsakov.numbers.PythagoreanDeuce = PythagoreanDeuce( // m = 2L, // n = 1L // ) primitivePythagoreanDeuce.triplet // res84: com.github.artemkorsakov.numbers.PythagoreanTriplet = PythagoreanTriplet( // a = 3L, // b = 4L, // c = 5L // ) primitivePythagoreanDeuce.nextPythagoreanDeuce.map(_.triplet) // res85: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 5L, b = 12L, c = 13L), // PythagoreanTriplet(a = 21L, b = 20L, c = 29L), // PythagoreanTriplet(a = 15L, b = 8L, c = 17L) // ) primitivePythagoreanDeuce.nextPythagoreanDeuce.flatMap(_.nextPythagoreanDeuce.map(_.triplet)) // res86: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 7L, b = 24L, c = 25L), // PythagoreanTriplet(a = 55L, b = 48L, c = 73L), // PythagoreanTriplet(a = 45L, b = 28L, c = 53L), // PythagoreanTriplet(a = 39L, b = 80L, c = 89L), // PythagoreanTriplet(a = 119L, b = 120L, c = 169L), // PythagoreanTriplet(a = 77L, b = 36L, c = 85L), // PythagoreanTriplet(a = 33L, b = 56L, c = 65L), // PythagoreanTriplet(a = 65L, b = 72L, c = 97L), // PythagoreanTriplet(a = 35L, b = 12L, c = 37L) // ) primitivePythagoreanTriplet // res87: com.github.artemkorsakov.numbers.PythagoreanTriplet = PythagoreanTriplet( // a = 3L, // b = 4L, // c = 5L // ) primitivePythagoreanTriplet.nextPythagoreanTriplet // res88: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 5L, b = 12L, c = 13L), // PythagoreanTriplet(a = 21L, b = 20L, c = 29L), // PythagoreanTriplet(a = 15L, b = 8L, c = 17L) // ) primitivePythagoreanTriplet.nextPythagoreanTriplet.flatMap(_.nextPythagoreanTriplet) // res89: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 7L, b = 24L, c = 25L), // PythagoreanTriplet(a = 55L, b = 48L, c = 73L), // PythagoreanTriplet(a = 45L, b = 28L, c = 53L), // PythagoreanTriplet(a = 39L, b = 80L, c = 89L), // PythagoreanTriplet(a = 119L, b = 120L, c = 169L), // PythagoreanTriplet(a = 77L, b = 36L, c = 85L), // PythagoreanTriplet(a = 33L, b = 56L, c = 65L), // PythagoreanTriplet(a = 65L, b = 72L, c = 97L), // PythagoreanTriplet(a = 35L, b = 12L, c = 37L) // ) pythagoreanTripletsWithGivenSum(1000) // res90: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 375L, b = 200L, c = 425L) // ) import com.github.artemkorsakov.numbers.CyclicNumbers._ (1 to 5).map(i =&gt; i.triangleNumber) // res91: IndexedSeq[Long] = Vector(1L, 3L, 6L, 10L, 15L) (1 to 5).map(i =&gt; i.squareNumber) // res92: IndexedSeq[Long] = Vector(1L, 4L, 9L, 16L, 25L) (1 to 5).map(i =&gt; i.pentagonalNumber) // res93: IndexedSeq[Long] = Vector(1L, 5L, 12L, 22L, 35L) (1 to 5).map(i =&gt; i.hexagonalNumber) // res94: IndexedSeq[Long] = Vector(1L, 6L, 15L, 28L, 45L) (1 to 5).map(i =&gt; i.heptagonalNumber) // res95: IndexedSeq[Long] = Vector(1L, 7L, 18L, 34L, 55L) (1 to 5).map(i =&gt; i.octagonalNumber) // res96: IndexedSeq[Long] = Vector(1L, 8L, 21L, 40L, 65L) 8256.isTriangle // res97: Boolean = true 5625.isSquare // res98: Boolean = true 2882.isPentagonal // res99: Boolean = true 8128.isHexagonal // res100: Boolean = true 2512.isHeptagonal // res101: Boolean = true 1281.isOctagonal // res102: Boolean = true import com.github.artemkorsakov.numbers.OtherNumbers._ (0 to 5).map(padovan) // res103: IndexedSeq[BigInt] = Vector(1, 0, 0, 1, 0, 1) (0 to 5).map(jacobsthal) // res104: IndexedSeq[BigInt] = Vector(0, 1, 1, 3, 5, 11) (0 to 5).map(pell) // res105: IndexedSeq[BigInt] = Vector(0, 1, 2, 5, 12, 29) (0 to 5).map(tribonacci) // res106: IndexedSeq[BigInt] = Vector(0, 0, 1, 1, 2, 4) (0 to 5).map(tetranacci) // res107: IndexedSeq[BigInt] = Vector(0, 0, 0, 1, 1, 2)"
    } ,    
    {
      "title": "Numbers description",
      "url": "/algorithms/docs/str/numbers_description.html",
      "content": "Number description in different languages. inEnglish Number description in English. Algorithm Complexity Sources English numerals Using import com.github.artemkorsakov.str.NumbersDescription._ 1435.inEnglish // res0: Option[String] = Some( // value = \"one thousand four hundred and thirty-five\" // ) 999999.inEnglish // res1: Option[String] = Some( // value = \"nine hundred and ninety-nine thousand nine hundred and ninety-nine\" // ) inRussian Number description in Russian. Algorithm Complexity Sources Using 11011435.inRussian // res2: Option[String] = Some(одиннадцать миллионов одиннадцать тысяч четыреста тридцать пять) 999999.inRussian // res3: Option[String] = Some(девятьсот девяносто девять тысяч девятьсот девяносто девять)"
    } ,    
    {
      "title": "Various math objects",
      "url": "/algorithms/docs/objects.html",
      "content": "Various math objects The package com.github.artemkorsakov.objects contains various math objects. You can use the package, for example, like this: import com.github.artemkorsakov.objects.MatrixLine._ Seq(1L, 2L, -3L).mul(Seq(-7L, 4L, 6L)) // res0: Option[Long] = Some(value = -17L) Seq(1L, 2L, -3L) * Seq(-7L, 4L, 6L) // res1: Option[Long] = Some(value = -17L) Seq(1007, 2456, -3466).mulMod(Seq(-3347, 4343, 6445), 1000) // res2: Option[Int] = Some(value = 609) import com.github.artemkorsakov.objects.Matrix._ Seq(Seq(1, 2), Seq(3, 4), Seq(5, 6)).matrixTranspose // res3: Seq[Seq[Int]] = Vector(Vector(1, 3, 5), Vector(2, 4, 6)) Seq(Seq(1, 3, 5), Seq(2, 4, 6)).matrixTranspose // res4: Seq[Seq[Int]] = Vector(Vector(1, 2), Vector(3, 4), Vector(5, 6)) Seq(Seq(1, 2), Seq(3, 4), Seq(5, 6)).matrixTranspose.matrixTranspose // res5: Seq[Seq[Int]] = Vector(Vector(1, 2), Vector(3, 4), Vector(5, 6)) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).minorMatrix(1, 2) // res6: Option[Seq[Seq[Int]]] = Some( // value = Vector(Vector(-2, -1, -4), Vector(-1, -1, 4), Vector(2, 1, -8)) // ) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).matrixDeterminant // res7: Option[Int] = Some(value = -8) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)) + Seq(Seq(8, -5, -6, -4), Seq(-13, -22, -11, -65), Seq(45, 45, 34, 35), Seq(23, 12, -33, -82)) // res8: Option[Seq[Seq[Int]]] = Some( // value = Vector( // Vector(6, -6, -7, -8), // Vector(-14, -24, -12, -71), // Vector(44, 44, 36, 39), // Vector(25, 13, -36, -90) // ) // ) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).mul(7) // res9: Seq[Seq[Int]] = Vector( // Vector(-14, -7, -7, -28), // Vector(-7, -14, -7, -42), // Vector(-7, -7, 14, 28), // Vector(14, 7, -21, -56) // ) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)) * 8 // res10: Seq[Seq[Int]] = Vector( // Vector(-16, -8, -8, -32), // Vector(-8, -16, -8, -48), // Vector(-8, -8, 16, 32), // Vector(16, 8, -24, -64) // ) Seq(Seq(-2, -1, -1, -4), Seq(-1, -2, -1, -6), Seq(-1, -1, 2, 4), Seq(2, 1, -3, -8)).mulMod(10, 11) // res11: Seq[Seq[Int]] = Vector( // Vector(2, 1, 1, 4), // Vector(1, 2, 1, 6), // Vector(1, 1, 9, 7), // Vector(9, 10, 3, 8) // ) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mul(Seq(Seq(1, 2, 3), Seq(-3, 5, 4), Seq(6, 2, 1), Seq(1, -1, 0))) // res12: Option[Seq[Seq[Int]]] = Some( // value = List(List(8, 25, 27), List(23, -1, -1), List(13, 18, 14)) // ) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)) * Seq(Seq(1, 2, 3), Seq(-3, 5, 4), Seq(6, 2, 1), Seq(1, -1, 0)) // res13: Option[Seq[Seq[Int]]] = Some( // value = List(List(8, 25, 27), List(23, -1, -1), List(13, 18, 14)) // ) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mulMod(Seq(Seq(1, 2, 3), Seq(-3, 5, 4), Seq(6, 2, 1), Seq(1, -1, 0)), 7) // res14: Option[Seq[Seq[Int]]] = Some( // value = List(List(1, 4, 6), List(2, 6, 6), List(6, 4, 0)) // ) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mul(Seq(1, -3, 6, 1)) // res15: Option[Seq[Int]] = Some(value = List(8, 23, 13)) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)) * Seq(1, -3, 6, 1) // res16: Option[Seq[Int]] = Some(value = List(8, 23, 13)) Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)).mulMod(Seq(1, -3, 6, 1), 7) // res17: Option[Seq[Int]] = Some(value = List(1, 2, 6)) Seq(1, -3, 6).mul(Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0))) // res18: Option[Seq[Int]] = Some(value = List(9, 19, 11, -1)) Seq(1, -3, 6) * Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)) // res19: Option[Seq[Int]] = Some(value = List(9, 19, 11, -1)) Seq(1, -3, 6).mulMod(Seq(Seq(3, 4, 2, 5), Seq(0, -1, 3, 2), Seq(1, 2, 3, 0)), 7) // res20: Option[Seq[Int]] = Some(value = List(2, 5, 4, 6)) Seq(Seq(2, 0), Seq(-1, 3)).power(2) // res21: Option[Seq[Seq[Int]]] = Some(value = List(List(4, 0), List(-5, 9))) val fibonacciMatrix = Seq(Seq(1, 1), Seq(1, 0)) // fibonacciMatrix: Seq[Seq[Int]] = List(List(1, 1), List(1, 0)) fibonacciMatrix.power(20) // res22: Option[Seq[Seq[Int]]] = Some( // value = List(List(10946, 6765), List(6765, 4181)) // ) Seq(Seq(1, 2, 1, 0), Seq(1, 1, 0, -1), Seq(-2, 0, 1, 2), Seq(0, 2, 1, 1)).power(100) // res23: Option[Seq[Seq[Int]]] = Some( // value = List( // List(1, 200, 100, 0), // List(100, 1, 0, -100), // List(-200, 0, 1, 200), // List(0, 200, 100, 1) // ) // ) fibonacciMatrix.powerMod(50, 1000000) // res24: Option[Seq[Seq[Int]]] = Some( // value = List(List(11074, 269025), List(269025, 742049)) // ) import com.github.artemkorsakov.objects.Triangle Triangle((-340, 495), (-153, -910), (835, -947)).getPointOnTriangleType((0, 0)) // res25: Triangle.PointOnTriangleType = Inside Triangle((-175, 41), (-421, -714), (574, -645)).getPointOnTriangleType((0, 0)) // res26: Triangle.PointOnTriangleType = Outside Triangle((-175, 41), (-421, -714), (574, -645)).getPointOnTriangleType((-175, 41)) // res27: Triangle.PointOnTriangleType = OnTheSide Triangle((-340, 495), (-153, -910), (835, -947)).isZeroPointInside // res28: Boolean = true Triangle((-175, 41), (-421, -714), (574, -645)).isZeroPointInside // res29: Boolean = false"
    } ,    
    {
      "title": "Operations with primes",
      "url": "/algorithms/docs/primes/oper_primes.html",
      "content": "Common operations with prime numbers. isPrime Determines if the given integer is prime. Algorithm A prime number greater than 1. All primes except 2 are odd. All primes greater than 3 can be written in the form 6k±1. Any number n can have only one primefactor greater than √n. The consequence for primality testing of a number n is: if we cannot find a number f less than or equal √n that divides n then n is prime: the only primefactor of n is n itself Complexity O(√n) Sources Project Euler: Problem 7 Project Euler: Problem 7 overview Using import com.github.artemkorsakov.primes.Primes._ 1000999.isPrime // res0: Boolean = true nextPrime Get next prime number for the given prime number. Algorithm The next prime number is 3 for 2. The next prime number is 5 for 3. If the current number % 3 is 1 then the next candidate is current number + 4 else current number + 2. If the next candidate is prime then return result else return to step 3. Complexity Sources Using 1000999.nextPrime // res1: Long = 1001003L isPrimeArray All prime numbers from 2 through n as a boolean array. Algorithm Create a list of consecutive integers from 2 through n: (2, 3, 4, …, n). Initially, let p equal 2, the smallest prime number. Enumerate the multiples of p by counting in increments of p from 2p to n, and mark them in the list (these will be 2p, 3p, 4p, …; the p itself should not be marked). Find the smallest number in the list greater than p that is not marked. If there was no such number, stop. Otherwise, let p now equal this new number (which is the next prime), and repeat from step 3. When the algorithm terminates, the numbers remaining not marked in the list are all the primes below n. Complexity O(n log(log n)) Sources Sieve of Eratosthenes Using isPrimeArray(5) // res2: Array[Boolean] = Array(false, false, true, true, false, true) primes All prime numbers from 2 through n. Algorithm Take isPrimeArray and filter by true Complexity O(n log(log n)) Sources Using primes(30) // res3: Array[Int] = Array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29) generatePrimes Get the given count of primes. Algorithm The result is obvious if count is less or equal 2. If count is more than 2 then start with Array(2, 3) Starting from 5 check each number of the form 6k±1 whether it is prime. Add to array if it is prime. If array’s size is less than count return to step 3. Complexity Sources Using generatePrimes(10) // res4: Array[Int] = Array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29) largestPrimeFactor Get the largest prime factor. Algorithm max start from 1, current prime start from 2. If prime is more than number return max. If number is divisible by prime then max takes the value of prime. While number is divisible by prime number is divided by prime. prime takes the value of the next prime number and return to step 2. Complexity Sources Using 600851475143L.largestPrimeFactor // res5: Long = 6857L smallestPrimeFactor Get the smallest prime factor. Algorithm For all numbers i from 2 to √n find first such as n % i == 0 and return it. Complexity O(√n) Sources Using 10965021787L.smallestPrimeFactor // res6: Long = 104711L smallestPrimeFactorArray Returns an array spf where spf(k) is the smallest prime factor of k, valid for 2 ≤ k ≤ n. For example: spf = {0, 0, 2, 3, 2, 5, 2, 7, 2, 3, 2}. Algorithm For all numbers i from 2 to k if the smallest prime factor has not yet been set then set i. For all numbers j from i2 to k by i step set the smallest prime factor as i. Return to step 2. Complexity Sources Using smallestPrimeFactorArray(10) // res7: Array[Int] = Array(0, 0, 2, 3, 2, 5, 2, 7, 2, 3, 2) primeFactorsWithPow For a given number return all its prime factors with powers. Algorithm Start: i is equal to 2, n is equal to number. If i is prime and n % i == 0 then let’s define pow is equal to 0. While n % i == 0, pow is incremented and n becomes equal to n/i. If n &gt; 1 then i is incremented and we return to step 2. Complexity Sources Using 1000.primeFactorsWithPow // res8: Map[Long, Long] = Map(2L -&gt; 3L, 5L -&gt; 3L) 1024.primeFactorsWithPow // res9: Map[Long, Long] = Map(2L -&gt; 10L) goldbach Goldbach’s conjecture says that every positive even number greater than 2 is the sum of two prime numbers. E.g. 28 = 5 + 23. It is one of the most famous facts in number theory that has not been proved to be correct in the general case. It has been numerically confirmed up to very large numbers (much larger than Scala’s Int can represent). Return the two prime numbers that sum up to a given even integer. Algorithm Complexity Sources Using 28.goldbach // res10: (Long, Long) = (5L, 23L) 1024.goldbach // res11: (Long, Long) = (3L, 1021L)"
    } ,    
    {
      "title": "Different algorithms",
      "url": "/algorithms/docs/operations.html",
      "content": "Different algorithms The package com.github.artemkorsakov.operations contains various simple algorithms. You can use the package, for example, like this: import com.github.artemkorsakov.operations.CommonOperations._ sumToGiven(1000000) // res0: Long = 500000500000L sumOfSquaresTo(1000) // res1: Long = 333833500L sumOfCubesTo(1000) // res2: Long = 250500250000L 1000.sqrt // res3: Double = 31.622776601684336 36.isSquare // res4: Boolean = true allSquares(2) // res5: IndexedSeq[Int] = Vector(16, 25, 36, 49, 64, 81) allSquares(1024, 1444) // res6: IndexedSeq[Int] = Vector(1024, 1089, 1156, 1225, 1296, 1369, 1444) allNumbersVariants(Set(2, 3, 5)) // res7: Set[Set[Int]] = HashSet( // Set(5, 3, 2), // Set(2), // Set(3, 2), // Set(5), // Set(5, 2), // Set(3), // Set(5, 3) // )"
    } ,    
    {
      "title": "Other numbers",
      "url": "/algorithms/docs/numbers/other_numbers.html",
      "content": "padovan Padovan sequence (or Padovan numbers): an = an-2 + an-3 with a0 = 1, a1 = a2 = 0. The beginning of the sequence is thus: 1, 0, 0, 1, 0, 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 12, 16, 21, 28, 37, 49, 65, 86, 114, 151, 200… Algorithm Complexity Sources Padovan sequence Using import com.github.artemkorsakov.numbers.OtherNumbers.padovan (0 to 5).map(padovan) // res0: IndexedSeq[BigInt] = Vector(1, 0, 0, 1, 0, 1) jacobsthal Jacobsthal sequence (or Jacobsthal numbers): an = an-1 + 2 * an-2 with a0 = 0, a1 = 1. Also an = nearest integer to 2n/3. The beginning of the sequence is thus: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, 5461, 10923, 21845, 43691, 87381, 174763, 349525… Algorithm Complexity Sources Jacobsthal sequence Using import com.github.artemkorsakov.numbers.OtherNumbers.jacobsthal (0 to 5).map(jacobsthal) // res1: IndexedSeq[BigInt] = Vector(0, 1, 1, 3, 5, 11) pell Pell numbers: an = 2 * an-1 + an-2 with a0 = 0, a1 = 1. The beginning of the sequence is thus: 0, 1, 2, 5, 12, 29, 70, 169, 408, 985, 2378, 5741, 13860, 33461, 80782, 195025, 470832, 1136689… Algorithm Complexity Sources Pell numbers Using import com.github.artemkorsakov.numbers.OtherNumbers.pell (0 to 5).map(pell) // res2: IndexedSeq[BigInt] = Vector(0, 1, 2, 5, 12, 29) tribonacci Tribonacci numbers: an = an-1 + an-2 + an-3 with a0 = a1 = 0, a2 = 1. The beginning of the sequence is thus: 0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415… Algorithm Complexity Sources Tribonacci numbers Using import com.github.artemkorsakov.numbers.OtherNumbers.tribonacci (0 to 5).map(tribonacci) // res3: IndexedSeq[BigInt] = Vector(0, 0, 1, 1, 2, 4) tetranacci Tetranacci numbers: an = an-1 + an-2 + an-3 + an-4 with a0 = a1 = a2 = 0, a3 = 1. The beginning of the sequence is thus: 0, 0, 0, 1, 1, 2, 4, 8, 15, 29, 56, 108, 208, 401, 773, 1490, 2872, 5536, 10671, 20569, 39648, 76424… Algorithm Complexity Sources Tetranacci numbers Using import com.github.artemkorsakov.numbers.OtherNumbers.tetranacci (0 to 5).map(tetranacci) // res4: IndexedSeq[BigInt] = Vector(0, 0, 0, 1, 1, 2)"
    } ,    
    {
      "title": "Palindrome",
      "url": "/algorithms/docs/numbers/palindrome.html",
      "content": "Palindrome. isPalindrome Is the given number a palindrome? Is the given number a palindrome in the base n system? Algorithm Complexity Sources Using import com.github.artemkorsakov.numbers.Palindrome._ BigInt(\"4668731596684224866951378664\").isPalindrome // res0: Boolean = true 4994.isPalindrome // res1: Boolean = true 4994.isPalindrome(2) // res2: Boolean = false 15.isPalindrome(2) // res3: Boolean = true 26.isPalindrome(3) // res4: Boolean = true 63.isPalindrome(4) // res5: Boolean = true"
    } ,    
    {
      "title": "Pandigital",
      "url": "/algorithms/docs/digital/pandigital.html",
      "content": "isPandigital Is a number an integer that has among its significant digits each digit used exactly once? Is a number an integer that has among its significant digits (from 1 to n) each digit used exactly once? Is a number an integer that has among its significant digits (from digits list) each digit used exactly once? Algorithm Complexity Sources Using import com.github.artemkorsakov.digital.Pandigital._ 192384576L.isPandigital // res0: Boolean = true 2134.isPandigital(4) // res1: Boolean = true 1406357289L.isPandigital(Array(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)) // res2: Boolean = true"
    } ,      
    {
      "title": "Perfect Numbers",
      "url": "/algorithms/docs/divisors/perfect_numbers.html",
      "content": "Operations with perfect numbers. perfectNumbersType Return perfectNumbersType: Perfect: a perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. Deficient: a deficient number is a positive integer that is less to the sum of its positive divisors, excluding the number itself. Abundant: an abundant number is a positive integer that is more to the sum of its positive divisors, excluding the number itself. Algorithm Complexity Sources Perfect numbers Using import com.github.artemkorsakov.divisors.PerfectNumbers._ 8128.perfectNumbersType // res0: PerfectNumbersType = Perfect"
    } ,    
    {
      "title": "Euler's totient function",
      "url": "/algorithms/docs/primes/phi_function.html",
      "content": "In number theory, Euler’s totient function counts the positive integers up to a given integer n that are relatively prime to n. totient Counts the positive integers up to a given integer n that are relatively prime to n. Algorithm Euler’s product formula: Complexity Sources wiki: Euler’s totient function Using import com.github.artemkorsakov.primes.PhiFunction._ 87109.totient // res0: Long = 79180L totientArray Euler’s totient function’s array Algorithm Use this formula: A consequence of this formula is the formula: Complexity Sources wiki: Euler’s totient function Using totientArray(10) // res1: Array[Long] = Array(0L, 1L, 1L, 2L, 2L, 4L, 2L, 6L, 4L, 6L, 4L)"
    } ,    
    {
      "title": "Poker",
      "url": "/algorithms/docs/games/poker.html",
      "content": "In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way: High Card: Highest value card. One Pair: Two cards of the same value. Two Pairs: Two different pairs. Three of a Kind: Three cards of the same value. Straight: All cards are consecutive values. Flush: All cards of the same suit. Full House: Three of a kind and a pair. Four of a Kind: Four cards of the same value. Straight Flush: All cards are consecutive values of same suit. Royal Flush: Ten, Jack, Queen, King, Ace, in same suit. The cards are valued in the order: 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace. If two players have the same ranked hands then the rank made up of the highest value wins; for example, a pair of eights beats a pair of fives (see example 1 below). But if two ranks tie, for example, both players have a pair of queens, then highest cards in each hand are compared (see example 4 below); if the highest cards tie then the next highest cards are compared, and so on. Consider the following five hands dealt to two players: Hand Player 1 Player 2 Who is a winner? 1 5H 5C 6S 7S KD (Pair of Fives) 2C 3S 8S 8D TD (Pair of Eights) Player 2 2 5D 8C 9S JS AC (Highest card Ace) 2C 5C 7D 8S QH (Highest card Queen) Player 1 3 2D 9C AS AH AC (Three Aces) 3D 6D 7D TD QD (Flush with Diamonds) Player 2 4 4D 6S 9H QH QC (Pair of Queens, Highest card Nine) 3D 6D 7H QD QS (Pair of Queens, Highest card Seven) Player 1 5 2H 2D 4C 4D 4S (Full House with Three Fours) 3C 3D 3S 9S 9D (Full House with Three Threes) Player 1 doesPlayer1Win Does first player win? Algorithm Complexity Sources Project Euler. Problem 54 Using import com.github.artemkorsakov.games.poker.Poker // Pair of Fives, Pair of Eights Poker(\"5H 5C 6S 7S KD\", \"2C 3S 8S 8D TD\").doesPlayer1Win // res0: Boolean = false // Highest card Ace, Highest card Queen Poker(\"5D 8C 9S JS AC\", \"2C 5C 7D 8S QH\").doesPlayer1Win // res1: Boolean = true // Three Aces, Flush with Diamonds Poker(\"2D 9C AS AH AC\", \"3D 6D 7D TD QD\").doesPlayer1Win // res2: Boolean = false // Pair of Queens Highest card Nine, Pair of Queens Highest card Seven Poker(\"4D 6S 9H QH QC\", \"3D 6D 7H QD QS\").doesPlayer1Win // res3: Boolean = true // Full House With Three Fours, Full House with Three Threes Poker(\"2H 2D 4C 4D 4S\", \"3C 3D 3S 9S 9D\").doesPlayer1Win // res4: Boolean = true"
    } ,    
    {
      "title": "Polynomial equation",
      "url": "/algorithms/docs/equations/polynomial_equation.html",
      "content": "polynomialCoefficients Returns the coefficients of a polynomial equation with the given power and array of solutions. For example, there is a equation a0x2 + a1x + a2 = b. If [b0, b1, b2] are solutions for x ∈ [1,2,3] then PolynomialEquation.polynomialCoefficients(3, Seq(b0, b1, b2)) returns coefficients [a0, a1, a2]. Algorithm Complexity Sources Polynomial Using import com.github.artemkorsakov.equations.PolynomialEquation PolynomialEquation.polynomialCoefficients(3, Array(1, 8, 27)) // res0: Array[Long] = Array(6L, -11L, 6L)"
    } ,    
    {
      "title": "Primes",
      "url": "/algorithms/docs/primes.html",
      "content": "Primes The package com.github.artemkorsakov.primes contains algorithms for working with prime numbers. You can use the package, for example, like this: import com.github.artemkorsakov.primes.Primes._ 1000999.isPrime // res0: Boolean = true 1000999.nextPrime // res1: Long = 1001003L isPrimeArray(6) // res2: Array[Boolean] = Array(false, false, true, true, false, true, false) primes(10) // res3: Array[Int] = Array(2, 3, 5, 7) generatePrimes(10) // res4: Array[Int] = Array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29) 600851475143L.largestPrimeFactor // res5: Long = 6857L 10965021787L.smallestPrimeFactor // res6: Long = 104711L smallestPrimeFactorArray(10) // res7: Array[Int] = Array(0, 0, 2, 3, 2, 5, 2, 7, 2, 3, 2) 1000.primeFactorsWithPow // res8: Map[Long, Long] = Map(2L -&gt; 3L, 5L -&gt; 3L) 1024.goldbach // res9: (Long, Long) = (3L, 1021L) import com.github.artemkorsakov.primes.PhiFunction._ 87109.totient // res10: Long = 79180L totientArray(10) // res11: Array[Long] = Array(0L, 1L, 1L, 2L, 2L, 4L, 2L, 6L, 4L, 6L, 4L) import com.github.artemkorsakov.primes.Radicals._ 504.rad // res12: Long = 42L allRads(10) // res13: Array[Int] = Array(0, 1, 2, 3, 2, 5, 6, 7, 2, 3, 10) 21.isSquareFree // res14: Boolean = true"
    } ,    
    {
      "title": "Pythagorean triplet",
      "url": "/algorithms/docs/numbers/pythagorean.html",
      "content": "A Pythagorean triple consists of three positive integers a, b, and c, such that a2 + b2 = c2. Such a triple is commonly written (a, b, c), and a well-known example is (3, 4, 5). If (a, b, c) is a Pythagorean triple, then so is (ka, kb, kc) for any positive integer k. A primitive Pythagorean triple is one in which a, b and c are coprime (that is, they have no common divisor larger than 1). A triangle whose sides form a Pythagorean triple is called a Pythagorean triangle, and is necessarily a right triangle. Euclid’s formula is a fundamental formula for generating Pythagorean triples given an arbitrary pair of integers m and n with m &gt; n &gt; 0. The formula states that the integers a=m2-n2, b=2mn, c=m2+n2 form a Pythagorean triple. The triple generated by Euclid’s formula is primitive if and only if m and n are coprime and not both odd. nextPythagoreanDeuce Tree of primitive Pythagorean triples. Method of generating the tree: Standard formula for generating all primitive Pythagorean triples: with m &gt; n &gt; 0 and m and n coprime and of opposite parity. Pairs (m, n) can be iterated by pre-multiplying them (expressed as a column vector) by any of each of which preserves the inequalities, coprimeness, and opposite parity. The resulting ternary tree, starting at (2,1), contains every such (m, n) pair exactly once. Algorithm Start from Complexity Sources Tree of primitive Pythagorean triples Using import com.github.artemkorsakov.numbers.PythagoreanDeuce._ primitivePythagoreanDeuce // res0: com.github.artemkorsakov.numbers.PythagoreanDeuce = PythagoreanDeuce( // m = 2L, // n = 1L // ) primitivePythagoreanDeuce.triplet // res1: com.github.artemkorsakov.numbers.PythagoreanTriplet = PythagoreanTriplet( // a = 3L, // b = 4L, // c = 5L // ) primitivePythagoreanDeuce.nextPythagoreanDeuce.map(_.triplet) // res2: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 5L, b = 12L, c = 13L), // PythagoreanTriplet(a = 21L, b = 20L, c = 29L), // PythagoreanTriplet(a = 15L, b = 8L, c = 17L) // ) primitivePythagoreanDeuce.nextPythagoreanDeuce.flatMap(_.nextPythagoreanDeuce.map(_.triplet)) // res3: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 7L, b = 24L, c = 25L), // PythagoreanTriplet(a = 55L, b = 48L, c = 73L), // PythagoreanTriplet(a = 45L, b = 28L, c = 53L), // PythagoreanTriplet(a = 39L, b = 80L, c = 89L), // PythagoreanTriplet(a = 119L, b = 120L, c = 169L), // PythagoreanTriplet(a = 77L, b = 36L, c = 85L), // PythagoreanTriplet(a = 33L, b = 56L, c = 65L), // PythagoreanTriplet(a = 65L, b = 72L, c = 97L), // PythagoreanTriplet(a = 35L, b = 12L, c = 37L) // ) nextPythagoreanTriplet Tree of primitive Pythagorean triples. Method of generating the tree: F. J. M. Barning showed that when any of the three matrices is multiplied on the right by a column vector whose components form a Pythagorean triple, then the result is another column vector whose components are a different Pythagorean triple. If the initial triple is primitive, then so is the one that results. Thus each primitive Pythagorean triple has three “children”. All primitive Pythagorean triples are descended in this way from the triple (3, 4, 5), and no primitive triple appears more than once. Algorithm Start from Complexity Sources Tree of primitive Pythagorean triples Using import com.github.artemkorsakov.numbers.PythagoreanTriplet._ primitivePythagoreanTriplet // res4: com.github.artemkorsakov.numbers.PythagoreanTriplet = PythagoreanTriplet( // a = 3L, // b = 4L, // c = 5L // ) primitivePythagoreanTriplet.nextPythagoreanTriplet // res5: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 5L, b = 12L, c = 13L), // PythagoreanTriplet(a = 21L, b = 20L, c = 29L), // PythagoreanTriplet(a = 15L, b = 8L, c = 17L) // ) primitivePythagoreanTriplet.nextPythagoreanTriplet.flatMap(_.nextPythagoreanTriplet) // res6: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 7L, b = 24L, c = 25L), // PythagoreanTriplet(a = 55L, b = 48L, c = 73L), // PythagoreanTriplet(a = 45L, b = 28L, c = 53L), // PythagoreanTriplet(a = 39L, b = 80L, c = 89L), // PythagoreanTriplet(a = 119L, b = 120L, c = 169L), // PythagoreanTriplet(a = 77L, b = 36L, c = 85L), // PythagoreanTriplet(a = 33L, b = 56L, c = 65L), // PythagoreanTriplet(a = 65L, b = 72L, c = 97L), // PythagoreanTriplet(a = 35L, b = 12L, c = 37L) // ) pythagoreanTripletsWithGivenSum Return all Pythagorean triplets such as a+b+c = sum. Algorithm Complexity Sources Project Euler. Problem 9 Using import com.github.artemkorsakov.numbers.PythagoreanTriplet._ pythagoreanTripletsWithGivenSum(1000) // res7: Seq[com.github.artemkorsakov.numbers.PythagoreanTriplet] = List( // PythagoreanTriplet(a = 375L, b = 200L, c = 425L) // )"
    } ,    
    {
      "title": "Quadratic equation",
      "url": "/algorithms/docs/equations/quadratic_equation.html",
      "content": "Solutions to a quadratic equation. solutionsInIntegers Integer solutions to a quadratic equation. Algorithm Complexity Sources Quadratic equation Using import com.github.artemkorsakov.equations._ QuadraticEquation(1, -5, -6).solutionsInIntegers // res0: Seq[Long] = List(6L, -1L) solutions Solutions to a quadratic equation in real numbers. Algorithm Complexity Sources Quadratic equation Using QuadraticEquation(1, -5, 5).solutions // res1: Seq[Double] = List(3.618033988749895, 1.381966011250105) solutionsInComplexNumbers Solutions to a quadratic equation in complex numbers. Algorithm Let If Δ &gt;= 0 then Else Complexity Sources Quadratic equation Using QuadraticEquation(1, -2, 2).solutionsInComplexNumbers // res2: Seq[com.github.artemkorsakov.numbers.ComplexNumber] = List( // ComplexNumber(a = 1.0, b = 1.0), // ComplexNumber(a = 1.0, b = -1.0) // )"
    } ,    
    {
      "title": "Radicals",
      "url": "/algorithms/docs/primes/radicals.html",
      "content": "In number theory, the radical of a positive integer n is defined as the product of the distinct prime numbers dividing n. Each prime factor of n occurs exactly once as a factor of this product: For example, 504 = 23 × 32 × 7, so rad(504) = 2 × 3 × 7 = 42. rad Return the product of distinct prime factors of n. Algorithm Formula: Complexity Sources wiki: Radical of an integer Using import com.github.artemkorsakov.primes.Radicals._ 504.rad // res0: Long = 42L allRads Return array of products of distinct prime factors of any n not more limit. Algorithm Let’s take an array of all prime numbers not exceeding the limit. For each prime number p take all numbers from 1 to limit / p. For each number i use formula: Complexity Sources Using allRads(10) // res1: Array[Int] = Array(0, 1, 2, 3, 2, 5, 6, 7, 2, 3, 10) isSquareFree Return true if number is a square-free integer. Algorithm Find first prime number p from 2 to √n such as n % p2 = 0. Complexity Sources Using 20.isSquareFree // res2: Boolean = false 21.isSquareFree // res3: Boolean = true"
    } ,    
    {
      "title": "Rational number/Fraction",
      "url": "/algorithms/docs/numbers/rational.html",
      "content": "A rational number is a number that can be expressed as the quotient or fraction p/q of two integers, a numerator p and a non-zero denominator q. addSubMulDiv Fraction operations: Addition, subtraction, multiplication, division and upend/reciprocal. Algorithm Complexity Sources Rational number Fraction Using import com.github.artemkorsakov.numbers.RationalNumber val x = new RationalNumber(1, 3) // x: RationalNumber = 1/3 val y = new RationalNumber(5, 7) // y: RationalNumber = 5/7 x.add(y) // res0: RationalNumber = 22/21 x.sub(y) // res1: RationalNumber = -8/21 x.mul(y) // res2: RationalNumber = 5/21 x.div(y) // res3: RationalNumber = 7/15 x + y // res4: RationalNumber = 22/21 x - y // res5: RationalNumber = -8/21 x * y // res6: RationalNumber = 5/21 x / y // res7: RationalNumber = 7/15 x.upend // res8: RationalNumber = 3/1 y.upend // res9: RationalNumber = 7/5 equal Returns true if the rational numbers are equal. Algorithm Complexity Sources Using x.equal(new RationalNumber(1, 3)) // res10: Boolean = true x.equal(new RationalNumber(-2, -6)) // res11: Boolean = true x.equal(new RationalNumber(3, 9)) // res12: Boolean = true x.equal(new RationalNumber(1, 4)) // res13: Boolean = false x == new RationalNumber(1, 3) // res14: Boolean = true x == new RationalNumber(-2, -6) // res15: Boolean = true x == new RationalNumber(3, 9) // res16: Boolean = true x == new RationalNumber(1, 4) // res17: Boolean = false compare Comparison of two fractions. Algorithm Complexity Sources Using import com.github.artemkorsakov.numbers.RationalNumber._ x &lt; y // res18: Boolean = true y &lt; x // res19: Boolean = false x &lt; x // res20: Boolean = false x &lt;= y // res21: Boolean = true x &lt;= x // res22: Boolean = true x &gt; y // res23: Boolean = false y &gt; x // res24: Boolean = true x &gt; x // res25: Boolean = false x &gt;= y // res26: Boolean = false x &gt;= x // res27: Boolean = true max(x, y) == y // res28: Boolean = true max(x, x) == x // res29: Boolean = true max(y, y) == y // res30: Boolean = true toPercent Fraction to percent. Algorithm Complexity Sources Using import com.github.artemkorsakov.numbers.RationalNumber new RationalNumber(5, 7).toPercent // res31: Double = 0.7142857142857143"
    } ,    
    {
      "title": "Roman numerals",
      "url": "/algorithms/docs/str/roman_numerals.html",
      "content": "About Roman Numerals. toMinimalRomanNumeral Roman number in its minimum notation. Algorithm Complexity Sources Roman Numerals About Roman Numerals Using import com.github.artemkorsakov.str.RomanNumerals._ \"MCCCCCCVI\".toMinimalRomanNumeral // res0: Option[String] = Some(value = \"MDCVI\") toArabic Roman number to Arabic. Algorithm Complexity Sources Using \"MCMLXXXIV\".toArabic // res1: Option[Long] = Some(value = 1984L) toRoman Arabic number to Roman. Algorithm Complexity Sources Using 1984.toRoman // res2: Option[String] = Some(value = \"MCMLXXXIV\")"
    } ,      
    {
      "title": "Sorting",
      "url": "/algorithms/docs/sort.html",
      "content": "{{page.title}} The package com.github.artemkorsakov.sort contains sorting algorithms. You can use the package, for example, like this: import com.github.artemkorsakov.sort.Sorting._ { val array = Array(5, 2, 4, 6, 1, 3) array.insertionSort() array } // res0: Array[Int] = Array(1, 2, 3, 4, 5, 6) { val array = Array(5, 2, 4, 6, 1, 3) array.insertionSortReverse() array } // res1: Array[Int] = Array(6, 5, 4, 3, 2, 1) { val array = Array(5, 2, 4, 6, 1, 3) array.selectionSort() array } // res2: Array[Int] = Array(1, 2, 3, 4, 5, 6) { val array = Array(5, 2, 4, 6, 1, 3) array.selectionSortReverse() array } // res3: Array[Int] = Array(6, 5, 4, 3, 2, 1) { val array = Array(5, 2, 4, 6, 1, 3) array.mergeSort() array } // res4: Array[Int] = Array(1, 2, 3, 4, 5, 6)"
    } ,    
    {
      "title": "Sorting Algorithms",
      "url": "/algorithms/docs/sort/sorting.html",
      "content": "Sorting algorithms insertionSort Insertion sort. Algorithm Complexity O(n2) Sources Insertion sort Using import com.github.artemkorsakov.sort.Sorting._ { val array = Array(5, 2, 4, 6, 1, 3) array.insertionSort() array } // res0: Array[Int] = Array(1, 2, 3, 4, 5, 6) insertionSortReverse Insertion sort. Algorithm Complexity O(n2) Sources Insertion sort Using { val array = Array(5, 2, 4, 6, 1, 3) array.insertionSortReverse() array } // res1: Array[Int] = Array(6, 5, 4, 3, 2, 1) selectionSort Selection sort. Algorithm Complexity О(n2) comparisons, О(n) swaps Sources Selection sort Using { val array = Array(5, 2, 4, 6, 1, 3) array.selectionSort() array } // res2: Array[Int] = Array(1, 2, 3, 4, 5, 6) selectionSortReverse Selection sort. Algorithm Complexity О(n2) comparisons, О(n) swaps Sources Selection sort Using { val array = Array(5, 2, 4, 6, 1, 3) array.selectionSortReverse() array } // res3: Array[Int] = Array(6, 5, 4, 3, 2, 1) mergeSort Merge sort. Algorithm Complexity О(n2) comparisons, О(n) swaps Sources Merge sort Using { val array = Array(5, 2, 4, 6, 1, 3) array.mergeSort() array } // res4: Array[Int] = Array(1, 2, 3, 4, 5, 6)"
    } ,    
    {
      "title": "Sources of algorithms",
      "url": "/algorithms/sources_of_algorithms.html",
      "content": "List of References Sites and articles Project Euler Wikipedia Ninety-Nine Scala Problems Books: …"
    } ,    
    {
      "title": "String Algorithms",
      "url": "/algorithms/docs/str.html",
      "content": "{{page.title}} The package com.github.artemkorsakov.str contains string algorithms. You can use the package, for example, like this: import com.github.artemkorsakov.str.StringAlgorithms._ sum(\"37107287533902102798797998220837590246510135740250\", \"46376937677490009712648124896970078050417018260538\") // res0: String = \"83484225211392112511446123117807668296927154000788\" \"37107287533902102798797998220837590246510135740250\" sum \"46376937677490009712648124896970078050417018260538\" // res1: String = \"83484225211392112511446123117807668296927154000788\" \"37107287533902102798797998220837590246510135740250\" |+| \"46376937677490009712648124896970078050417018260538\" // res2: String = \"83484225211392112511446123117807668296927154000788\" areAnagrams(\"post\", \"stop\") // res3: Boolean = true \"\\\"COLIN\\\"\".alphabeticalValue // res4: Int = 53 import com.github.artemkorsakov.str.NumbersDescription._ 1435.inEnglish // res5: Option[String] = Some(one thousand four hundred and thirty-five) 999999.inEnglish // res6: Option[String] = Some(nine hundred and ninety-nine thousand nine hundred and ninety-nine) 11011435.inRussian // res7: Option[String] = Some(одиннадцать миллионов одиннадцать тысяч четыреста тридцать пять) 999999.inRussian // res8: Option[String] = Some(девятьсот девяносто девять тысяч девятьсот девяносто девять) import com.github.artemkorsakov.str.RomanNumerals._ \"MCCCCCCVI\".toMinimalRomanNumeral // res9: Option[String] = Some(value = \"MDCVI\") \"MCMLXXXIV\".toArabic // res10: Option[Long] = Some(value = 1984L) 1984.toRoman // res11: Option[String] = Some(value = \"MCMLXXXIV\")"
    } ,    
    {
      "title": "Operations with strings",
      "url": "/algorithms/docs/str/string_algorithms.html",
      "content": "sum Returns the sum of two numbers given as a string. Algorithm Given two numbers: first and second. If one of these numbers is empty return the other number. Define sumLast as sum of last symbols of the numbers. Define sumFirst as sum(first0, second0) where first0 and second0 are the numbers without last symbol. If sumLast is more than 9 define sumFirst = sum(sumFirst, “1”) and sumLast = sumLast - 10. Return sumFirst + sumLast. Complexity Sources Using import com.github.artemkorsakov.str.StringAlgorithms._ sum(\"37107287533902102798797998220837590246510135740250\", \"46376937677490009712648124896970078050417018260538\") // res0: String = \"83484225211392112511446123117807668296927154000788\" \"37107287533902102798797998220837590246510135740250\" sum \"46376937677490009712648124896970078050417018260538\" // res1: String = \"83484225211392112511446123117807668296927154000788\" \"37107287533902102798797998220837590246510135740250\" |+| \"46376937677490009712648124896970078050417018260538\" // res2: String = \"83484225211392112511446123117807668296927154000788\" areAnagrams Are two words anagrams? It is the same as Digits - containTheSameDigits Algorithm Complexity Sources Using areAnagrams(\"post\", \"stop\") // res3: Boolean = true alphabeticalValue Project Euler Problem 22. Algorithm Complexity Sources Project Euler Problem 22 Using \"\\\"COLIN\\\"\".alphabeticalValue // res4: Int = 53"
    } ,    
    {
      "title": "SuDoku",
      "url": "/algorithms/docs/games/sudoku.html",
      "content": "Su Doku (Japanese meaning number place) is the name given to a popular puzzle concept. Its origin is unclear, but credit must be attributed to Leonhard Euler who invented a similar, and much more difficult, puzzle idea called Latin Squares. The objective of Su Doku puzzles, however, is to replace the blanks (or zeros) in a 9 by 9 grid in such that each row, column, and 3 by 3 box contains each of the digits 1 to 9. Below is an example of a typical starting puzzle grid and its solution grid. A well constructed Su Doku puzzle has a unique solution and can be solved by logic, although it may be necessary to employ “guess and test” methods in order to eliminate options (there is much contested opinion over this). The complexity of the search determines the difficulty of the puzzle; the example above is considered easy because it can be solved by straight forward direct deduction. result Returns a solution for the given SuDoku. Algorithm Complexity Sources Project Euler. Problem 96 Using import com.github.artemkorsakov.games.sudoku.SuDoku._ val src = \"003020600\\n900305001\\n001806400\\n008102900\\n700000008\\n006708200\\n002609500\\n800203009\\n005010300\" // src: String = \"\"\"003020600 // 900305001 // 001806400 // 008102900 // 700000008 // 006708200 // 002609500 // 800203009 // 005010300\"\"\" toSuDoku(src).get.result.foreach(_.foreach(row =&gt; println(row.mkString(\"|\", \"\", \"|\")))) // |483921657| // |967345821| // |251876493| // |548132976| // |729564138| // |136798245| // |372689514| // |814253769| // |695417382|"
    } ,    
    {
      "title": "Three colours",
      "url": "/algorithms/docs/combinatorics/three_colours.html",
      "content": "countABCRows We have A white balls, B black balls and C grey balls. How many different options to arrange these balls in a row? Algorithm Let’s define min, mid, max as the values of a, b, c in ascending order. If min is less than 0 then return 0. If min and mid are 0 then return 1. Else countABCRows(min, mid, max) = countABCRows(min - 1, mid, max) + countABCRows(min, mid - 1, max) + countABCRows(min, mid, max - 1) Complexity Sources Using import com.github.artemkorsakov.combinatorics.ThreeColours._ countABCRows(2, 2, 2) // res0: Long = 90L"
    } ,    
    {
      "title": "Trees",
      "url": "/algorithms/docs/trees.html",
      "content": "{{page.title}} The package com.github.artemkorsakov.trees contains algorithms with trees. You can use the package, for example, like this: import com.github.artemkorsakov.trees.BinaryTree.Tree._ import com.github.artemkorsakov.trees.BinaryTree._ val simpleTree = Node('a', Node('b', Node('d'), Node('e')), Node('c', End, Node('f', Node('g'), End))) // simpleTree: Node[Char] = Node( // value = 'a', // left = Node( // value = 'b', // left = Node(value = 'd', left = , right = ), // right = Node(value = 'e', left = , right = ) // ), // right = Node( // value = 'c', // left = , // right = Node( // value = 'f', // left = Node(value = 'g', left = , right = ), // right = // ) // ) // ) simpleTree.nodeCount // res0: Int = 7 simpleTree.height // res1: Int = 4 simpleTree.leafCount // res2: Int = 3 simpleTree.leafList // res3: List[Char] = List('d', 'e', 'g') simpleTree.internalList // res4: List[Char] = List('a', 'b', 'c', 'f') simpleTree.atLevel(3) // res5: List[Char] = List('d', 'e', 'f') simpleTree.isMirrorOf(Node('a', Node('b', Node('d', End, Node('e')), End), Node('c', Node('g'), Node('f')))) // res6: Boolean = true simpleTree.isSymmetric // res7: Boolean = false Node('a', Node('b', Node('d', End, Node('e')), End), Node('c', End, Node('f', Node('g'), End))).isSymmetric // res8: Boolean = true End.addValue(2).addValue(3).addValue(0).addValue(1).addValue(-1) // res9: Tree[Int] = Node( // value = 2, // left = Node( // value = 0, // left = Node(value = -1, left = , right = ), // right = Node(value = 1, left = , right = ) // ), // right = Node(value = 3, left = , right = ) // ) mirror(simpleTree) // res10: Tree[Char] = Node( // value = 'a', // left = Node( // value = 'c', // left = Node( // value = 'f', // left = , // right = Node(value = 'g', left = , right = ) // ), // right = // ), // right = Node( // value = 'b', // left = Node(value = 'e', left = , right = ), // right = Node(value = 'd', left = , right = ) // ) // ) Tree.fromList(List(5, 3, 18, 1, 4, 12, 21)) // res11: Tree[Int] = Node( // value = 5, // left = Node( // value = 3, // left = Node(value = 1, left = , right = ), // right = Node(value = 4, left = , right = ) // ), // right = Node( // value = 18, // left = Node(value = 12, left = , right = ), // right = Node(value = 21, left = , right = ) // ) // ) Tree.fromString(\"a(b(d,e),c(,f(g,)))\") // res12: Tree[Char] = Node( // value = 'a', // left = Node( // value = 'b', // left = Node(value = 'd', left = , right = ), // right = Node(value = 'e', left = , right = ) // ), // right = Node( // value = 'c', // left = , // right = Node( // value = 'f', // left = Node(value = 'g', left = , right = ), // right = // ) // ) // ) Tree.completeBinaryTree(17, \"x\") // res13: Tree[String] = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ), // right = Node(value = \"x\", left = , right = ) // ), // right = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ) // ), // right = Node( // value = \"x\", // left = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ), // right = Node( // value = \"x\", // left = Node(value = \"x\", left = , right = ), // right = Node(value = \"x\", left = , right = ) // ) // ) // )"
    } ,    
    {
      "title": "Triangle",
      "url": "/algorithms/docs/objects/triangle.html",
      "content": "getPointOnTriangleType Returns the position of a point relative to a triangle: inside, outside, on the side. Algorithm Complexity Sources Triangle Using import com.github.artemkorsakov.objects.Triangle Triangle((-340, 495), (-153, -910), (835, -947)).getPointOnTriangleType((0, 0)) // res0: Triangle.PointOnTriangleType = Inside Triangle((-175, 41), (-421, -714), (574, -645)).getPointOnTriangleType((0, 0)) // res1: Triangle.PointOnTriangleType = Outside Triangle((-175, 41), (-421, -714), (574, -645)).getPointOnTriangleType((-175, 41)) // res2: Triangle.PointOnTriangleType = OnTheSide isZeroPointInside Is zero point inside the triangle? Algorithm Complexity Sources Using import com.github.artemkorsakov.objects.Triangle Triangle((-340, 495), (-153, -910), (835, -947)).isZeroPointInside // res3: Boolean = true Triangle((-175, 41), (-421, -714), (574, -645)).isZeroPointInside // res4: Boolean = false"
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
